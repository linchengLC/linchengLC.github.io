<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lin&#39;s blog</title>
    <link>https://linchengLC.github.io/</link>
    <description>Recent content on lin&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 12 Nov 2019 15:11:17 +0800</lastBuildDate>
    
        <atom:link href="https://linchengLC.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang的Channel底层原理</title>
      <link>https://linchengLC.github.io/post/golang%E7%9A%84channel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 12 Nov 2019 15:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/golang%E7%9A%84channel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</guid>
      
        <description>

&lt;h2 id=&#34;channel的整体结构图&#34;&gt;channel的整体结构图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1b52ab08?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;简单说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sendx&lt;/code&gt;和&lt;code&gt;recvx&lt;/code&gt;用于记录&lt;code&gt;buf&lt;/code&gt;这个循环链表中的~发送或者接收的~index&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lock&lt;/code&gt;是个互斥锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;recvq&lt;/code&gt;和&lt;code&gt;sendq&lt;/code&gt;分别是接收(&amp;lt;-channel)或者发送(channel &amp;lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;源码位于&lt;code&gt;/runtime/chan.go&lt;/code&gt;中(目前版本：1.11)。结构体为&lt;code&gt;hchan&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type hchan struct {
    qcount   uint           // total data in the queue
    dataqsiz uint           // size of the circular queue
    buf      unsafe.Pointer // points to an array of dataqsiz elements
    elemsize uint16
    closed   uint32
    elemtype *_type // element type
    sendx    uint   // send index
    recvx    uint   // receive index
    recvq    waitq  // list of recv waiters
    sendq    waitq  // list of send waiters

    // lock protects all fields in hchan, as well as several
    // fields in sudogs blocked on this channel.
    //
    // Do not change another G&#39;s status while holding this lock
    // (in particular, do not ready a G), as this can deadlock
    // with stack shrinking.
    lock mutex
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们来详细介绍&lt;code&gt;hchan&lt;/code&gt;中各部分是如何使用的。&lt;/p&gt;

&lt;h2 id=&#34;先从创建开始&#34;&gt;先从创建开始&lt;/h2&gt;

&lt;p&gt;我们首先创建一个channel。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch:=make(chan int,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1b6f96fc?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;创建channel实际上就是在内存中实例化了一个&lt;code&gt;hchan&lt;/code&gt;的结构体，并返回一个ch指针，我们使用过程中channel在函数之间的传递都是用的这个指针，这就是为什么函数传递中无需使用channel的指针，而直接使用channel就行了，因为channel本身就是一个指针。&lt;/p&gt;

&lt;h2 id=&#34;channel中发送send-ch-xxx-和recv-ch-接收&#34;&gt;channel中发送send(ch &amp;lt;- xxx)和recv(&amp;lt;- ch)接收&lt;/h2&gt;

&lt;p&gt;先考虑一个问题，如果你想让goroutine以先进先出(FIFO)的方式进入一个结构体中，你会怎么操作？ 加锁！对的！channel就是用了一个锁。hchan本身包含一个互斥锁&lt;code&gt;mutex&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;channel中队列是如何实现的&#34;&gt;channel中队列是如何实现的&lt;/h3&gt;

&lt;p&gt;channel中有个缓存buf，是用来缓存数据的(假如实例化了带缓存的channel的话)队列。我们先来看看是如何实现“队列”的。 还是刚才创建的那个channel&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch:=make(chan int,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1cde7276?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当使用&lt;code&gt;send (ch &amp;lt;- xx)&lt;/code&gt;或者&lt;code&gt;recv ( &amp;lt;-ch)&lt;/code&gt;的时候，首先要锁住&lt;code&gt;hchan&lt;/code&gt;这个结构体。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1d501497?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后开始&lt;code&gt;send (ch &amp;lt;- xx)&lt;/code&gt;数据。&lt;/p&gt;

&lt;p&gt;一&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch&amp;lt;-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch&amp;lt;-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch&amp;lt;-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候满了，队列塞不进去了，动态图表示为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1d1b2a18?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后是取&lt;code&gt;recv ( &amp;lt;-ch)&lt;/code&gt;的过程，是个逆向的操作，也是需要加锁。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1d6c9e89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;然后开始&lt;code&gt;recv(&amp;lt;-ch)&lt;/code&gt;数据。&lt;/p&gt;

&lt;p&gt;一&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c0265625b?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意以上两幅图中&lt;code&gt;buf&lt;/code&gt;和&lt;code&gt;recvx&lt;/code&gt;以及&lt;code&gt;sendx&lt;/code&gt;的变化，&lt;code&gt;recvx&lt;/code&gt;和&lt;code&gt;sendx&lt;/code&gt;是根据循环链表&lt;code&gt;buf&lt;/code&gt;的变动而改变的。 至于为什么channel会使用循环链表作为缓存结构，我个人认为是在缓存列表在动态的&lt;code&gt;send&lt;/code&gt;和&lt;code&gt;recv&lt;/code&gt;过程中，定位当前&lt;code&gt;send&lt;/code&gt;或者&lt;code&gt;recvx&lt;/code&gt;的位置、选择&lt;code&gt;send&lt;/code&gt;的和&lt;code&gt;recvx&lt;/code&gt;的位置比较方便吧，只要顺着链表顺序一直旋转操作就好。&lt;/p&gt;

&lt;p&gt;缓存中按链表顺序存放，取数据的时候按链表顺序读取，符合FIFO的原则。&lt;/p&gt;

&lt;h3 id=&#34;send-recv的细化操作&#34;&gt;send/recv的细化操作&lt;/h3&gt;

&lt;p&gt;注意：缓存链表中以上每一步的操作，都是需要加锁操作的！&lt;/p&gt;

&lt;p&gt;每一步的操作的细节可以细化为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一，加锁&lt;/li&gt;
&lt;li&gt;第二，把数据从goroutine中copy到”队列“中（或者从队列中copy到goroutine中）&lt;/li&gt;
&lt;li&gt;第三，释放锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一步的操作总结为动态图为：（发送过程）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c18219683?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;或者为：（接收过程）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c1e49b4ab?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以不难看出，Go中那句经典的话：&lt;code&gt;Do not communicate by sharing memory; instead, share memory by communicating.&lt;/code&gt;的具体实现就是利用channel把数据从一端copy到了另一端！ 还真是符合&lt;code&gt;channel&lt;/code&gt;的英文含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c4eff6a3f?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;当channel缓存满了之后会发生什么-这其中的原理是怎样的&#34;&gt;当channel缓存满了之后会发生什么？这其中的原理是怎样的？&lt;/h3&gt;

&lt;p&gt;使用的时候，我们都知道，当channel缓存满了，或者没有缓存的时候，我们继续send(ch &amp;lt;- xxx)或者recv(&amp;lt;- ch)会阻塞当前goroutine，但是，是如何实现的呢？&lt;/p&gt;

&lt;p&gt;我们知道，Go的goroutine是用户态的线程(&lt;code&gt;user-space threads&lt;/code&gt;)，用户态的线程是需要自己去调度的，Go有运行时的scheduler去帮我们完成调度这件事情。关于Go的调度模型GMP模型我在此不做赘述，如果不了解，可以看我另一篇文章(&lt;a href=&#34;https://i6448038.github.io/2017/12/04/golang-concurrency-principle/&#34;&gt;Go调度原理&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;goroutine的阻塞操作，实际上是调用&lt;code&gt;send (ch &amp;lt;- xx)&lt;/code&gt;或者&lt;code&gt;recv ( &amp;lt;-ch)&lt;/code&gt;的时候主动触发的，具体请看以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//goroutine1 中，记做G1

ch := make(chan int, 3)

ch &amp;lt;- 1
ch &amp;lt;- 1
ch &amp;lt;- 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c655f26fa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c7e0fa6b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候G1正在正常运行,当再次进行send操作(ch&amp;lt;-1)的时候，会主动调用Go的调度器,让G1等待，并从让出M，让其他G去使用&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42cdb898891?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同时G1也会被抽象成含有G1指针和send元素的&lt;code&gt;sudog&lt;/code&gt;结构体保存到hchan的&lt;code&gt;sendq&lt;/code&gt;中等待被唤醒。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c806cd876?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么，G1什么时候被唤醒呢？这个时候G2隆重登场。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42cf9b7a64b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;G2执行了recv操作&lt;code&gt;p := &amp;lt;-ch&lt;/code&gt;，于是会发生以下的操作：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d08bb757a?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1，并把G1放到可运行的Goroutine队列中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d0cad71b9?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;假如是先进行执行recv操作的g2会怎么样&#34;&gt;假如是先进行执行recv操作的G2会怎么样？&lt;/h3&gt;

&lt;p&gt;你可能会顺着以上的思路反推。首先：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d3ba03093?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。 G2还会被抽象成含有G2指针和recv空元素的&lt;code&gt;sudog&lt;/code&gt;结构体保存到hchan的&lt;code&gt;recvq&lt;/code&gt;中等待被唤醒&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d58ad1148?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此时恰好有个goroutine G1开始向channel中推送数据 &lt;code&gt;ch &amp;lt;- 1&lt;/code&gt;。 此时，非常有意思的事情发生了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42ddfc04314?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。 这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。&lt;/p&gt;

&lt;p&gt;之后的事情显而易见：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42e5df40117?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文章来源：&lt;a href=&#34;https://juejin.im/post/5cb3445f6fb9a068b748ab75&#34;&gt;https://juejin.im/post/5cb3445f6fb9a068b748ab75&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>为什么使用sync.pool</title>
      <link>https://linchengLC.github.io/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8sync.pool/</link>
      <pubDate>Sat, 26 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8sync.pool/</guid>
      
        <description>

&lt;h4 id=&#34;介绍&#34;&gt;介绍&lt;/h4&gt;

&lt;p&gt;因为使用Pool后更快。通过文章底部存储库中的基准测试可以较少4982被的内存占用&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/19131697-1865b3c2c293422e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;相比之下，Pool的性能更快更好&lt;/p&gt;

&lt;h4 id=&#34;ok-这究竟是怎么回事呢&#34;&gt;ok，这究竟是怎么回事呢？&lt;/h4&gt;

&lt;p&gt;垃圾回收定期执行。如果你的代码不断地在进行一些数据结构中分配内存然后释放他们，这就会导致收集器的不断工作，使得更多的内存和CPU被用来在初始化结构体时分配资源。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对sync/pool.go的描述如下：&lt;/p&gt;

&lt;p&gt;Pool是一组可以单独保存和检索的临时对象。&lt;/p&gt;

&lt;p&gt;Pool可以安全地同时使用多个Goroutine。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;sync.Pool&lt;/strong&gt;允许我们重用内存而非重新分配。&lt;/p&gt;

&lt;p&gt;此外，如果你使用的 http 服务器接收带有 JSON 请求体的 post 请求，并且它必须被解码到结构体中，你可以使用 &lt;strong&gt;sync.Pool&lt;/strong&gt; 来节省内存并减少服务器响应时间。&lt;/p&gt;

&lt;h2 id=&#34;sync-pool-用法&#34;&gt;sync.Pool 用法&lt;/h2&gt;

&lt;p&gt;sync.Pool 构造很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var bufferPool = sync.Pool{	
	New: func() interface{} {		
			return new(bytes.Buffer)	
	},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你将会创建一个 Pool 和新的缓冲区。你可以这样创建第一个缓冲区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buffer := bufferPool.Get().(*bytes.Buffer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;get 方法会返回 Pool 中已存在的 *&lt;strong&gt;bytes.Buffer&lt;/strong&gt;，否则将调用 &lt;strong&gt;New&lt;/strong&gt; 方法来初始化新的 *&lt;strong&gt;bytes.Buffer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但在缓冲区使用后，你必须将其重置并放回 Pool 中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buffer.Reset()bufferPool.Put(buffer)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基准测试&#34;&gt;基准测试&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;参数解释：&lt;/p&gt;

&lt;p&gt;数字&lt;code&gt;8&lt;/code&gt;表示&lt;code&gt;GOMAXPROCS&lt;/code&gt;的值，这个对于并发基准测试很重要。&lt;code&gt;5000000&lt;/code&gt;和&lt;code&gt;384ns/op&lt;/code&gt;表示每次调用&lt;code&gt;bytes.Buffer&lt;/code&gt;函数耗时&lt;code&gt;384ns&lt;/code&gt;，这个结果是&lt;code&gt;5000000&lt;/code&gt;次调用的平均值，&lt;code&gt;0 B/op&lt;/code&gt;表示每次操作内存分配了0字节，&lt;code&gt;0 allocs/op&lt;/code&gt;则表示每次操作进行了0次内存分配。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;将-json-编码为-bytes-buffer&#34;&gt;将 JSON 编码为 bytes.Buffer&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 对 JSON 编码的代码段
BenchmarkReadStreamWithPool-8        5000000        384 ns/op   0 B/op   0allocs/op
BenchmarkReadStreamWithoutPool-8     3000000        554 ns/op   160 B/op 2 allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们得到了 44% 的性能提升并且节省了非常多的内存 (160B/ops vs 0B/ops)。&lt;/p&gt;

&lt;h3 id=&#34;将字节写入-bufio-writer&#34;&gt;将字节写入 bufio.Writer&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;BenchmarkWriteBufioWithPool-8       10000000        123 ns/op      128 B/op 2allocs/op
BenchmarkWriteBufioWithoutPool-8     2000000        651 ns/op     4288 B/op 4allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们得到了 5 倍性能提升并且减少了 32 倍内存使用。&lt;/p&gt;

&lt;h3 id=&#34;将-json-解码为-struct&#34;&gt;将 JSON 解码为 struct&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;BenchmarkJsonDecodeWithPool-8        1000000       1729 ns/op     1128 B/op 8allocs/op
BenchmarkJsonDecodeWithoutPool-8     1000000       1751 ns/op     1160 B/op 9allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为 JSON 解码操作太难，我们的性能只提升了 1%，我们无法通过重用结构体得到正常的提升。&lt;/p&gt;

&lt;h3 id=&#34;gzip-字节&#34;&gt;Gzip 字节&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;BenchmarkWriteGzipWithPool-8          500000    2339 ns/op      162 B/op 2allocs/op
BenchmarkWriteGzipWithoutPool-8       10000     105288 ns/op   807088 B/op 16allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等等，什么？性能提升了 45 倍并且内存使用量减少了 4982 倍。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;务必使用 &lt;strong&gt;sync.Pool&lt;/strong&gt; ！它确实可以节省内存并提高应用程序的性能。&lt;/p&gt;

&lt;p&gt;基准测试的 Github 存储库在&lt;a href=&#34;https://github.com/Mnwa/GoBench&#34;&gt;&lt;strong&gt;这里&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;摘自Go语言中文网&lt;a href=&#34;https://studygolang.com/articles/21384&#34;&gt;https://studygolang.com/articles/21384&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>面试知识点</title>
      <link>https://linchengLC.github.io/post/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Sat, 26 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      
        <description>

&lt;h1 id=&#34;1-前言&#34;&gt;1. 前言&lt;/h1&gt;

&lt;p&gt;面试考察的知识点多而杂，要完全掌握需要花费大量的时间和精力。但是面试中经常被问到的知识点却没有多少，你完全可以用 20% 的时间去掌握 80% 常问的知识点。在这里我将这 80% 常问的知识点整理出来，方便大家快速地掌握。这些知识点也标注了重要程度，从而让大家可以根据知识点的重要程度去制定学习计划。&lt;/p&gt;

&lt;p&gt;如果你想更好的学习这些知识点，可以参考 &lt;a href=&#34;https://xiaozhuanlan.com/topic/4150387926&#34;&gt;知识总结方法&lt;/a&gt; 一文，这篇文章的最后给出了比本文更详细的思维导图。&lt;/p&gt;

&lt;p&gt;下图列出了面试考察的九大知识点，也标出了重要程度和复习难度。&lt;/p&gt;

&lt;p&gt;其实重要程度根据不同的公司会有所不同，针对上图做一下几点说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;分布式与系统设计部分对于大厂面试来说至关重要，但是小厂面试考察的会少一点。&lt;/li&gt;
&lt;li&gt;语言基础部分，阿里喜欢问 Java、腾讯喜欢问 C++，其它大厂面试考察会少一些，小厂面试会考察多一些。&lt;/li&gt;
&lt;li&gt;数据库、中间件和框架部分对于大厂面试来说不是那么重要，但是对于小厂面试会重要一些。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后再说一下项目部分，它在实习招聘阶段中不是特别重要，但是在校园招聘阶段重要程度会增高。但是如果你的学历不好，而且没有博客、开源项目、竞赛等加分项，那么最好做个比较出色的项目来增加简历通过率。&lt;/p&gt;

&lt;p&gt;💻&lt;/p&gt;

&lt;h1 id=&#34;2-操作系统&#34;&gt;2. 操作系统&lt;/h1&gt;

&lt;h2 id=&#34;2-1-基础&#34;&gt;2.1 基础&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ 进程与线程的本质区别、以及各自的使用场景。&lt;/li&gt;
&lt;li&gt;★☆☆ 进程状态。&lt;/li&gt;
&lt;li&gt;★★★ 进程调度算法的特点以及使用场景。&lt;/li&gt;
&lt;li&gt;★☆☆ 线程实现的方式。&lt;/li&gt;
&lt;li&gt;★★☆ 协程的作用。&lt;/li&gt;
&lt;li&gt;★★☆ 常见进程同步问题。&lt;/li&gt;
&lt;li&gt;★★★ 进程通信方法的特点以及使用场景。&lt;/li&gt;
&lt;li&gt;★★★ 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁。&lt;/li&gt;
&lt;li&gt;★★★ 虚拟内存的作用，分页系统实现虚拟内存原理。&lt;/li&gt;
&lt;li&gt;★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。&lt;/li&gt;
&lt;li&gt;★★★ 比较分页与分段的区别。&lt;/li&gt;
&lt;li&gt;★★★ 分析静态链接的不足，以及动态链接的特点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-2-linux&#34;&gt;2.2 Linux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 文件系统的原理，特别是 inode 和 block。数据恢复原理。&lt;/li&gt;
&lt;li&gt;★★★ 硬链接与软链接的区别。&lt;/li&gt;
&lt;li&gt;★★☆ 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。&lt;/li&gt;
&lt;li&gt;★★★ 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;☁️&lt;/p&gt;

&lt;h1 id=&#34;3-网络&#34;&gt;3. 网络&lt;/h1&gt;

&lt;h2 id=&#34;3-1-基础&#34;&gt;3.1 基础&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ 各层协议的作用，以及 TCP/IP 协议的特点。&lt;/li&gt;
&lt;li&gt;★★☆ 以太网的特点，以及帧结构。&lt;/li&gt;
&lt;li&gt;★★☆ 集线器、交换机、路由器的作用，以及所属的网络层。&lt;/li&gt;
&lt;li&gt;★★☆ IP 数据数据报常见字段的作用。&lt;/li&gt;
&lt;li&gt;★☆☆ ARP 协议的作用，以及维护 ARP 缓存的过程。&lt;/li&gt;
&lt;li&gt;★★☆ ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。&lt;/li&gt;
&lt;li&gt;★★★ UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。&lt;/li&gt;
&lt;li&gt;★★★ 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。&lt;/li&gt;
&lt;li&gt;★★★ 可靠传输原理，并设计可靠 UDP 协议。&lt;/li&gt;
&lt;li&gt;★★☆ TCP 拥塞控制的作用，理解具体原理。&lt;/li&gt;
&lt;li&gt;★★☆ DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-2-http&#34;&gt;3.2 HTTP&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。&lt;/li&gt;
&lt;li&gt;★★☆ HTTP 状态码。&lt;/li&gt;
&lt;li&gt;★★★ Cookie 作用、安全性问题、和 Session 的比较。&lt;/li&gt;
&lt;li&gt;★★☆ 缓存 的Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。&lt;/li&gt;
&lt;li&gt;★★★ 长连接与短连接原理以及使用场景，流水线。&lt;/li&gt;
&lt;li&gt;★★★ HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。&lt;/li&gt;
&lt;li&gt;★★☆ HTTP/1.x 的缺陷，以及 HTTP/2 的特点。&lt;/li&gt;
&lt;li&gt;★★★ HTTP/1.1 的特性。&lt;/li&gt;
&lt;li&gt;★★☆ HTTP 与 FTP 的比较。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-3-socket&#34;&gt;3.3 Socket&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 五种 IO 模型的特点以及比较。&lt;/li&gt;
&lt;li&gt;★★★ select、poll、epoll 的原理、比较、以及使用场景；epoll 的水平触发与边缘触发。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;💾&lt;/p&gt;

&lt;h1 id=&#34;4-数据库&#34;&gt;4. 数据库&lt;/h1&gt;

&lt;h2 id=&#34;4-1-sql&#34;&gt;4.1 SQL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 手写 SQL 语句，特别是连接查询与分组查询。&lt;/li&gt;
&lt;li&gt;★★☆ 连接查询与子查询的比较。&lt;/li&gt;
&lt;li&gt;★★☆ drop、delete、truncate 比较。&lt;/li&gt;
&lt;li&gt;★★☆ 视图的作用，以及何时能更新视图。&lt;/li&gt;
&lt;li&gt;★☆☆ 理解存储过程、触发器等作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-2-系统原理&#34;&gt;4.2 系统原理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ ACID 的作用以及实现原理。&lt;/li&gt;
&lt;li&gt;★★★ 四大隔离级别，以及不可重复读和幻影读的出现原因。&lt;/li&gt;
&lt;li&gt;★★☆ 封锁的类型以及粒度，两段锁协议，隐式和显示锁定。&lt;/li&gt;
&lt;li&gt;★★★ 乐观锁与悲观锁。&lt;/li&gt;
&lt;li&gt;★★★ MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读。&lt;/li&gt;
&lt;li&gt;★★☆ 范式理论。&lt;/li&gt;
&lt;li&gt;★★★ SQL 与 NoSQL 的比较。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-3-mysql&#34;&gt;4.3 MySQL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ B+ Tree 原理，与其它查找树的比较。&lt;/li&gt;
&lt;li&gt;★★★ MySQL 索引以及优化。&lt;/li&gt;
&lt;li&gt;★★★ 查询优化。&lt;/li&gt;
&lt;li&gt;★★★ InnoDB 与 MyISAM 比较。&lt;/li&gt;
&lt;li&gt;★★☆ 水平切分与垂直切分。&lt;/li&gt;
&lt;li&gt;★★☆ 主从复制原理、作用、实现。&lt;/li&gt;
&lt;li&gt;★☆☆ redo、undo、binlog 日志的作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-4-redis&#34;&gt;4.4 Redis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 字典和跳跃表原理分析。&lt;/li&gt;
&lt;li&gt;★★★ 使用场景。&lt;/li&gt;
&lt;li&gt;★★★ 与 Memchached 的比较。&lt;/li&gt;
&lt;li&gt;★☆☆ 数据淘汰机制。&lt;/li&gt;
&lt;li&gt;★★☆ RDB 和 AOF 持久化机制。&lt;/li&gt;
&lt;li&gt;★★☆ 事件驱动模型。&lt;/li&gt;
&lt;li&gt;★☆☆ 主从复制原理。&lt;/li&gt;
&lt;li&gt;★★★ 集群与分布式。&lt;/li&gt;
&lt;li&gt;★★☆ 事务原理。&lt;/li&gt;
&lt;li&gt;★★★ 线程安全问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🎨&lt;/p&gt;

&lt;h1 id=&#34;5-面向对象&#34;&gt;5. 面向对象&lt;/h1&gt;

&lt;h2 id=&#34;5-1-思想&#34;&gt;5.1 思想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ 面向对象三大特性&lt;/li&gt;
&lt;li&gt;★☆☆ 设计原则&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-2-设计模式&#34;&gt;5.2 设计模式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 设计模式的作用。&lt;/li&gt;
&lt;li&gt;★★★ 手写单例模式，特别是双重检验锁以及静态内部类。&lt;/li&gt;
&lt;li&gt;★★★ 手写工厂模式。&lt;/li&gt;
&lt;li&gt;★★★ 理解 MVC，结合 SpringMVC 回答。&lt;/li&gt;
&lt;li&gt;★★★ 理解代理模式，结合 Spring 中的 AOP 回答。&lt;/li&gt;
&lt;li&gt;★★★ 分析 JDK 中常用的设计模式，例如装饰者模式、适配器模式、迭代器模式等。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>反转整数</title>
      <link>https://linchengLC.github.io/post/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
      <pubDate>Fri, 18 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
      
        <description>&lt;p&gt;给定一个 32 位有符号整数，将整数中的数字进行反转。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 123&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 321&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; -123&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; -321&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 120&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 21&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31 ,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现思路:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1.如果x为负数则将标志位sign置为-1，并且将x变为正数&lt;/p&gt;

&lt;p&gt;2.for循环&lt;/p&gt;

&lt;p&gt;对x取10余得到temp&lt;/p&gt;

&lt;p&gt;放入res头内res*10+temp&lt;/p&gt;

&lt;p&gt;将x去除末尾&lt;/p&gt;

&lt;p&gt;3.还原x的符号到res&lt;/p&gt;

&lt;p&gt;4.处理res的溢出问题，使用math.maxint32和math.minint32&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;代码实现:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Reverse Integer
 * 反转整数
*/
import (
	“math”
)
func reverse(x int) int {
	sign := 1
	// 处理负数
	if x &amp;lt; 0 {
		sign = -1
		x = -1 * x
	}
	res := 0
	for x &amp;gt; 0 {
		// 取出x的末尾
		temp := x % 10
		// 放入 res 的开头
		res = res*10 + temp
		// x 去除末尾
		x = x / 10
	}
	// 还原 x 的符号到 res
	res = sign * res
	// 处理 res 的溢出问题
	if res &amp;gt; math.MaxInt32 || res &amp;lt; math.MinInt32 {
		res = 0
	}
	return res
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>罗马数字转换为整数</title>
      <link>https://linchengLC.github.io/post/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0/</link>
      <pubDate>Fri, 18 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0/</guid>
      
        <description>&lt;p&gt;罗马数字包含以下七种字符： I ， V ， X ， L ， C ， D 和 M 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符&lt;/strong&gt;  &lt;strong&gt;数值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I 1&lt;/p&gt;

&lt;p&gt;V 5&lt;/p&gt;

&lt;p&gt;X 10&lt;/p&gt;

&lt;p&gt;L 50&lt;/p&gt;

&lt;p&gt;C 100&lt;/p&gt;

&lt;p&gt;D 500&lt;/p&gt;

&lt;p&gt;M 1000&lt;/p&gt;

&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII , 即为 XX + V + II 。&lt;/p&gt;

&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII ，而是 IV 。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX 。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。&lt;/li&gt;
&lt;li&gt;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;III&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;IV&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 4&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;IX&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 9&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 4:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;LVIII&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 58&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解释:&lt;/strong&gt; C = 100, L = 50, XXX = 30, III = 3.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 5:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;MCMXCIV&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 1994&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解释:&lt;/strong&gt; M = 1000, CM = 900, XC = 90, IV = 4.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现思路:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1.定义一个map用于存储每个罗马数字代表的整数&lt;/p&gt;

&lt;p&gt;2.定义一个sign标志用于判断前一个罗马数字是否小于后一个罗马数字，如果小于则将sign标志置为-1&lt;/p&gt;

&lt;p&gt;3.从后往前循环遍历字符串，如果前一个罗马数字通过map获取到的值(temp)小于后一个(last)，sign=-1&lt;/p&gt;

&lt;p&gt;​    res=sign*temp&lt;/p&gt;

&lt;p&gt;​    last=temp&lt;/p&gt;

&lt;p&gt;4.返回res&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;代码实现:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Roman to Integer
 * 罗马数字转整数
*/
func romanToInt(s string) int {
	res := 0
	m := map[byte]int{
		‘I’: 1,
		‘V’: 5,
		‘X’: 10,
		‘L’: 50,
		‘C’: 100,
		‘D’: 500,
		‘M’: 1000,
	}
	last := 0
	for i := len(s) - 1; i &amp;gt;= 0; i— {
		temp := m[s[i]]
		sign := 1
		if temp &amp;lt; last {
			//小数在大数的左边，要减去小数
			sign = -1
		}
		res += sign * temp
		last = temp
	}
    return res
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>About</title>
      <link>https://linchengLC.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;

&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
