<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lin&#39;s blog</title>
    <link>https://linchengLC.github.io/</link>
    <description>Recent content on lin&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 12 Nov 2019 15:11:17 +0800</lastBuildDate>
    
        <atom:link href="https://linchengLC.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang的Channel底层原理</title>
      <link>https://linchengLC.github.io/post/golang%E7%9A%84channel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 12 Nov 2019 15:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/golang%E7%9A%84channel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</guid>
      
        <description>

&lt;h2 id=&#34;channel的整体结构图&#34;&gt;channel的整体结构图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1b52ab08?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;简单说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sendx&lt;/code&gt;和&lt;code&gt;recvx&lt;/code&gt;用于记录&lt;code&gt;buf&lt;/code&gt;这个循环链表中的~发送或者接收的~index&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lock&lt;/code&gt;是个互斥锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;recvq&lt;/code&gt;和&lt;code&gt;sendq&lt;/code&gt;分别是接收(&amp;lt;-channel)或者发送(channel &amp;lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;源码位于&lt;code&gt;/runtime/chan.go&lt;/code&gt;中(目前版本：1.11)。结构体为&lt;code&gt;hchan&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type hchan struct {
    qcount   uint           // total data in the queue
    dataqsiz uint           // size of the circular queue
    buf      unsafe.Pointer // points to an array of dataqsiz elements
    elemsize uint16
    closed   uint32
    elemtype *_type // element type
    sendx    uint   // send index
    recvx    uint   // receive index
    recvq    waitq  // list of recv waiters
    sendq    waitq  // list of send waiters

    // lock protects all fields in hchan, as well as several
    // fields in sudogs blocked on this channel.
    //
    // Do not change another G&#39;s status while holding this lock
    // (in particular, do not ready a G), as this can deadlock
    // with stack shrinking.
    lock mutex
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们来详细介绍&lt;code&gt;hchan&lt;/code&gt;中各部分是如何使用的。&lt;/p&gt;

&lt;h2 id=&#34;先从创建开始&#34;&gt;先从创建开始&lt;/h2&gt;

&lt;p&gt;我们首先创建一个channel。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch:=make(chan int,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1b6f96fc?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;创建channel实际上就是在内存中实例化了一个&lt;code&gt;hchan&lt;/code&gt;的结构体，并返回一个ch指针，我们使用过程中channel在函数之间的传递都是用的这个指针，这就是为什么函数传递中无需使用channel的指针，而直接使用channel就行了，因为channel本身就是一个指针。&lt;/p&gt;

&lt;h2 id=&#34;channel中发送send-ch-xxx-和recv-ch-接收&#34;&gt;channel中发送send(ch &amp;lt;- xxx)和recv(&amp;lt;- ch)接收&lt;/h2&gt;

&lt;p&gt;先考虑一个问题，如果你想让goroutine以先进先出(FIFO)的方式进入一个结构体中，你会怎么操作？ 加锁！对的！channel就是用了一个锁。hchan本身包含一个互斥锁&lt;code&gt;mutex&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;channel中队列是如何实现的&#34;&gt;channel中队列是如何实现的&lt;/h3&gt;

&lt;p&gt;channel中有个缓存buf，是用来缓存数据的(假如实例化了带缓存的channel的话)队列。我们先来看看是如何实现“队列”的。 还是刚才创建的那个channel&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch:=make(chan int,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1cde7276?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当使用&lt;code&gt;send (ch &amp;lt;- xx)&lt;/code&gt;或者&lt;code&gt;recv ( &amp;lt;-ch)&lt;/code&gt;的时候，首先要锁住&lt;code&gt;hchan&lt;/code&gt;这个结构体。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1d501497?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后开始&lt;code&gt;send (ch &amp;lt;- xx)&lt;/code&gt;数据。&lt;/p&gt;

&lt;p&gt;一&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch&amp;lt;-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch&amp;lt;-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch&amp;lt;-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候满了，队列塞不进去了，动态图表示为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1d1b2a18?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后是取&lt;code&gt;recv ( &amp;lt;-ch)&lt;/code&gt;的过程，是个逆向的操作，也是需要加锁。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1d6c9e89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;然后开始&lt;code&gt;recv(&amp;lt;-ch)&lt;/code&gt;数据。&lt;/p&gt;

&lt;p&gt;一&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c0265625b?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意以上两幅图中&lt;code&gt;buf&lt;/code&gt;和&lt;code&gt;recvx&lt;/code&gt;以及&lt;code&gt;sendx&lt;/code&gt;的变化，&lt;code&gt;recvx&lt;/code&gt;和&lt;code&gt;sendx&lt;/code&gt;是根据循环链表&lt;code&gt;buf&lt;/code&gt;的变动而改变的。 至于为什么channel会使用循环链表作为缓存结构，我个人认为是在缓存列表在动态的&lt;code&gt;send&lt;/code&gt;和&lt;code&gt;recv&lt;/code&gt;过程中，定位当前&lt;code&gt;send&lt;/code&gt;或者&lt;code&gt;recvx&lt;/code&gt;的位置、选择&lt;code&gt;send&lt;/code&gt;的和&lt;code&gt;recvx&lt;/code&gt;的位置比较方便吧，只要顺着链表顺序一直旋转操作就好。&lt;/p&gt;

&lt;p&gt;缓存中按链表顺序存放，取数据的时候按链表顺序读取，符合FIFO的原则。&lt;/p&gt;

&lt;h3 id=&#34;send-recv的细化操作&#34;&gt;send/recv的细化操作&lt;/h3&gt;

&lt;p&gt;注意：缓存链表中以上每一步的操作，都是需要加锁操作的！&lt;/p&gt;

&lt;p&gt;每一步的操作的细节可以细化为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一，加锁&lt;/li&gt;
&lt;li&gt;第二，把数据从goroutine中copy到”队列“中（或者从队列中copy到goroutine中）&lt;/li&gt;
&lt;li&gt;第三，释放锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一步的操作总结为动态图为：（发送过程）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c18219683?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;或者为：（接收过程）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c1e49b4ab?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以不难看出，Go中那句经典的话：&lt;code&gt;Do not communicate by sharing memory; instead, share memory by communicating.&lt;/code&gt;的具体实现就是利用channel把数据从一端copy到了另一端！ 还真是符合&lt;code&gt;channel&lt;/code&gt;的英文含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c4eff6a3f?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;当channel缓存满了之后会发生什么-这其中的原理是怎样的&#34;&gt;当channel缓存满了之后会发生什么？这其中的原理是怎样的？&lt;/h3&gt;

&lt;p&gt;使用的时候，我们都知道，当channel缓存满了，或者没有缓存的时候，我们继续send(ch &amp;lt;- xxx)或者recv(&amp;lt;- ch)会阻塞当前goroutine，但是，是如何实现的呢？&lt;/p&gt;

&lt;p&gt;我们知道，Go的goroutine是用户态的线程(&lt;code&gt;user-space threads&lt;/code&gt;)，用户态的线程是需要自己去调度的，Go有运行时的scheduler去帮我们完成调度这件事情。关于Go的调度模型GMP模型我在此不做赘述，如果不了解，可以看我另一篇文章(&lt;a href=&#34;https://i6448038.github.io/2017/12/04/golang-concurrency-principle/&#34;&gt;Go调度原理&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;goroutine的阻塞操作，实际上是调用&lt;code&gt;send (ch &amp;lt;- xx)&lt;/code&gt;或者&lt;code&gt;recv ( &amp;lt;-ch)&lt;/code&gt;的时候主动触发的，具体请看以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//goroutine1 中，记做G1

ch := make(chan int, 3)

ch &amp;lt;- 1
ch &amp;lt;- 1
ch &amp;lt;- 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c655f26fa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c7e0fa6b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候G1正在正常运行,当再次进行send操作(ch&amp;lt;-1)的时候，会主动调用Go的调度器,让G1等待，并从让出M，让其他G去使用&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42cdb898891?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同时G1也会被抽象成含有G1指针和send元素的&lt;code&gt;sudog&lt;/code&gt;结构体保存到hchan的&lt;code&gt;sendq&lt;/code&gt;中等待被唤醒。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c806cd876?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么，G1什么时候被唤醒呢？这个时候G2隆重登场。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42cf9b7a64b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;G2执行了recv操作&lt;code&gt;p := &amp;lt;-ch&lt;/code&gt;，于是会发生以下的操作：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d08bb757a?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1，并把G1放到可运行的Goroutine队列中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d0cad71b9?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;假如是先进行执行recv操作的g2会怎么样&#34;&gt;假如是先进行执行recv操作的G2会怎么样？&lt;/h3&gt;

&lt;p&gt;你可能会顺着以上的思路反推。首先：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d3ba03093?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。 G2还会被抽象成含有G2指针和recv空元素的&lt;code&gt;sudog&lt;/code&gt;结构体保存到hchan的&lt;code&gt;recvq&lt;/code&gt;中等待被唤醒&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d58ad1148?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此时恰好有个goroutine G1开始向channel中推送数据 &lt;code&gt;ch &amp;lt;- 1&lt;/code&gt;。 此时，非常有意思的事情发生了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42ddfc04314?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。 这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。&lt;/p&gt;

&lt;p&gt;之后的事情显而易见：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42e5df40117?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>为什么使用sync.pool</title>
      <link>https://linchengLC.github.io/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8sync.pool/</link>
      <pubDate>Sat, 26 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8sync.pool/</guid>
      
        <description>

&lt;h4 id=&#34;介绍&#34;&gt;介绍&lt;/h4&gt;

&lt;p&gt;因为使用Pool后更快。通过文章底部存储库中的基准测试可以较少4982被的内存占用&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/19131697-1865b3c2c293422e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;相比之下，Pool的性能更快更好&lt;/p&gt;

&lt;h4 id=&#34;ok-这究竟是怎么回事呢&#34;&gt;ok，这究竟是怎么回事呢？&lt;/h4&gt;

&lt;p&gt;垃圾回收定期执行。如果你的代码不断地在进行一些数据结构中分配内存然后释放他们，这就会导致收集器的不断工作，使得更多的内存和CPU被用来在初始化结构体时分配资源。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对sync/pool.go的描述如下：&lt;/p&gt;

&lt;p&gt;Pool是一组可以单独保存和检索的临时对象。&lt;/p&gt;

&lt;p&gt;Pool可以安全地同时使用多个Goroutine。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;sync.Pool&lt;/strong&gt;允许我们重用内存而非重新分配。&lt;/p&gt;

&lt;p&gt;此外，如果你使用的 http 服务器接收带有 JSON 请求体的 post 请求，并且它必须被解码到结构体中，你可以使用 &lt;strong&gt;sync.Pool&lt;/strong&gt; 来节省内存并减少服务器响应时间。&lt;/p&gt;

&lt;h2 id=&#34;sync-pool-用法&#34;&gt;sync.Pool 用法&lt;/h2&gt;

&lt;p&gt;sync.Pool 构造很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var bufferPool = sync.Pool{	
	New: func() interface{} {		
			return new(bytes.Buffer)	
	},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你将会创建一个 Pool 和新的缓冲区。你可以这样创建第一个缓冲区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buffer := bufferPool.Get().(*bytes.Buffer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;get 方法会返回 Pool 中已存在的 *&lt;strong&gt;bytes.Buffer&lt;/strong&gt;，否则将调用 &lt;strong&gt;New&lt;/strong&gt; 方法来初始化新的 *&lt;strong&gt;bytes.Buffer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但在缓冲区使用后，你必须将其重置并放回 Pool 中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buffer.Reset()bufferPool.Put(buffer)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基准测试&#34;&gt;基准测试&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;参数解释：&lt;/p&gt;

&lt;p&gt;数字&lt;code&gt;8&lt;/code&gt;表示&lt;code&gt;GOMAXPROCS&lt;/code&gt;的值，这个对于并发基准测试很重要。&lt;code&gt;5000000&lt;/code&gt;和&lt;code&gt;384ns/op&lt;/code&gt;表示每次调用&lt;code&gt;bytes.Buffer&lt;/code&gt;函数耗时&lt;code&gt;384ns&lt;/code&gt;，这个结果是&lt;code&gt;5000000&lt;/code&gt;次调用的平均值，&lt;code&gt;0 B/op&lt;/code&gt;表示每次操作内存分配了0字节，&lt;code&gt;0 allocs/op&lt;/code&gt;则表示每次操作进行了0次内存分配。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;将-json-编码为-bytes-buffer&#34;&gt;将 JSON 编码为 bytes.Buffer&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 对 JSON 编码的代码段
BenchmarkReadStreamWithPool-8        5000000        384 ns/op   0 B/op   0allocs/op
BenchmarkReadStreamWithoutPool-8     3000000        554 ns/op   160 B/op 2 allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们得到了 44% 的性能提升并且节省了非常多的内存 (160B/ops vs 0B/ops)。&lt;/p&gt;

&lt;h3 id=&#34;将字节写入-bufio-writer&#34;&gt;将字节写入 bufio.Writer&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;BenchmarkWriteBufioWithPool-8       10000000        123 ns/op      128 B/op 2allocs/op
BenchmarkWriteBufioWithoutPool-8     2000000        651 ns/op     4288 B/op 4allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们得到了 5 倍性能提升并且减少了 32 倍内存使用。&lt;/p&gt;

&lt;h3 id=&#34;将-json-解码为-struct&#34;&gt;将 JSON 解码为 struct&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;BenchmarkJsonDecodeWithPool-8        1000000       1729 ns/op     1128 B/op 8allocs/op
BenchmarkJsonDecodeWithoutPool-8     1000000       1751 ns/op     1160 B/op 9allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为 JSON 解码操作太难，我们的性能只提升了 1%，我们无法通过重用结构体得到正常的提升。&lt;/p&gt;

&lt;h3 id=&#34;gzip-字节&#34;&gt;Gzip 字节&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;BenchmarkWriteGzipWithPool-8          500000    2339 ns/op      162 B/op 2allocs/op
BenchmarkWriteGzipWithoutPool-8       10000     105288 ns/op   807088 B/op 16allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等等，什么？性能提升了 45 倍并且内存使用量减少了 4982 倍。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;务必使用 &lt;strong&gt;sync.Pool&lt;/strong&gt; ！它确实可以节省内存并提高应用程序的性能。&lt;/p&gt;

&lt;p&gt;基准测试的 Github 存储库在&lt;a href=&#34;https://github.com/Mnwa/GoBench&#34;&gt;&lt;strong&gt;这里&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;摘自Go语言中文网&lt;a href=&#34;https://studygolang.com/articles/21384&#34;&gt;https://studygolang.com/articles/21384&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>面试知识点</title>
      <link>https://linchengLC.github.io/post/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Sat, 26 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      
        <description>

&lt;h1 id=&#34;1-前言&#34;&gt;1. 前言&lt;/h1&gt;

&lt;p&gt;面试考察的知识点多而杂，要完全掌握需要花费大量的时间和精力。但是面试中经常被问到的知识点却没有多少，你完全可以用 20% 的时间去掌握 80% 常问的知识点。在这里我将这 80% 常问的知识点整理出来，方便大家快速地掌握。这些知识点也标注了重要程度，从而让大家可以根据知识点的重要程度去制定学习计划。&lt;/p&gt;

&lt;p&gt;如果你想更好的学习这些知识点，可以参考 &lt;a href=&#34;https://xiaozhuanlan.com/topic/4150387926&#34;&gt;知识总结方法&lt;/a&gt; 一文，这篇文章的最后给出了比本文更详细的思维导图。&lt;/p&gt;

&lt;p&gt;下图列出了面试考察的九大知识点，也标出了重要程度和复习难度。&lt;/p&gt;

&lt;p&gt;其实重要程度根据不同的公司会有所不同，针对上图做一下几点说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;分布式与系统设计部分对于大厂面试来说至关重要，但是小厂面试考察的会少一点。&lt;/li&gt;
&lt;li&gt;语言基础部分，阿里喜欢问 Java、腾讯喜欢问 C++，其它大厂面试考察会少一些，小厂面试会考察多一些。&lt;/li&gt;
&lt;li&gt;数据库、中间件和框架部分对于大厂面试来说不是那么重要，但是对于小厂面试会重要一些。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后再说一下项目部分，它在实习招聘阶段中不是特别重要，但是在校园招聘阶段重要程度会增高。但是如果你的学历不好，而且没有博客、开源项目、竞赛等加分项，那么最好做个比较出色的项目来增加简历通过率。&lt;/p&gt;

&lt;p&gt;💻&lt;/p&gt;

&lt;h1 id=&#34;2-操作系统&#34;&gt;2. 操作系统&lt;/h1&gt;

&lt;h2 id=&#34;2-1-基础&#34;&gt;2.1 基础&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ 进程与线程的本质区别、以及各自的使用场景。&lt;/li&gt;
&lt;li&gt;★☆☆ 进程状态。&lt;/li&gt;
&lt;li&gt;★★★ 进程调度算法的特点以及使用场景。&lt;/li&gt;
&lt;li&gt;★☆☆ 线程实现的方式。&lt;/li&gt;
&lt;li&gt;★★☆ 协程的作用。&lt;/li&gt;
&lt;li&gt;★★☆ 常见进程同步问题。&lt;/li&gt;
&lt;li&gt;★★★ 进程通信方法的特点以及使用场景。&lt;/li&gt;
&lt;li&gt;★★★ 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁。&lt;/li&gt;
&lt;li&gt;★★★ 虚拟内存的作用，分页系统实现虚拟内存原理。&lt;/li&gt;
&lt;li&gt;★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。&lt;/li&gt;
&lt;li&gt;★★★ 比较分页与分段的区别。&lt;/li&gt;
&lt;li&gt;★★★ 分析静态链接的不足，以及动态链接的特点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-2-linux&#34;&gt;2.2 Linux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 文件系统的原理，特别是 inode 和 block。数据恢复原理。&lt;/li&gt;
&lt;li&gt;★★★ 硬链接与软链接的区别。&lt;/li&gt;
&lt;li&gt;★★☆ 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。&lt;/li&gt;
&lt;li&gt;★★★ 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;☁️&lt;/p&gt;

&lt;h1 id=&#34;3-网络&#34;&gt;3. 网络&lt;/h1&gt;

&lt;h2 id=&#34;3-1-基础&#34;&gt;3.1 基础&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ 各层协议的作用，以及 TCP/IP 协议的特点。&lt;/li&gt;
&lt;li&gt;★★☆ 以太网的特点，以及帧结构。&lt;/li&gt;
&lt;li&gt;★★☆ 集线器、交换机、路由器的作用，以及所属的网络层。&lt;/li&gt;
&lt;li&gt;★★☆ IP 数据数据报常见字段的作用。&lt;/li&gt;
&lt;li&gt;★☆☆ ARP 协议的作用，以及维护 ARP 缓存的过程。&lt;/li&gt;
&lt;li&gt;★★☆ ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。&lt;/li&gt;
&lt;li&gt;★★★ UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。&lt;/li&gt;
&lt;li&gt;★★★ 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。&lt;/li&gt;
&lt;li&gt;★★★ 可靠传输原理，并设计可靠 UDP 协议。&lt;/li&gt;
&lt;li&gt;★★☆ TCP 拥塞控制的作用，理解具体原理。&lt;/li&gt;
&lt;li&gt;★★☆ DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-2-http&#34;&gt;3.2 HTTP&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。&lt;/li&gt;
&lt;li&gt;★★☆ HTTP 状态码。&lt;/li&gt;
&lt;li&gt;★★★ Cookie 作用、安全性问题、和 Session 的比较。&lt;/li&gt;
&lt;li&gt;★★☆ 缓存 的Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。&lt;/li&gt;
&lt;li&gt;★★★ 长连接与短连接原理以及使用场景，流水线。&lt;/li&gt;
&lt;li&gt;★★★ HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。&lt;/li&gt;
&lt;li&gt;★★☆ HTTP/1.x 的缺陷，以及 HTTP/2 的特点。&lt;/li&gt;
&lt;li&gt;★★★ HTTP/1.1 的特性。&lt;/li&gt;
&lt;li&gt;★★☆ HTTP 与 FTP 的比较。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-3-socket&#34;&gt;3.3 Socket&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 五种 IO 模型的特点以及比较。&lt;/li&gt;
&lt;li&gt;★★★ select、poll、epoll 的原理、比较、以及使用场景；epoll 的水平触发与边缘触发。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;💾&lt;/p&gt;

&lt;h1 id=&#34;4-数据库&#34;&gt;4. 数据库&lt;/h1&gt;

&lt;h2 id=&#34;4-1-sql&#34;&gt;4.1 SQL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 手写 SQL 语句，特别是连接查询与分组查询。&lt;/li&gt;
&lt;li&gt;★★☆ 连接查询与子查询的比较。&lt;/li&gt;
&lt;li&gt;★★☆ drop、delete、truncate 比较。&lt;/li&gt;
&lt;li&gt;★★☆ 视图的作用，以及何时能更新视图。&lt;/li&gt;
&lt;li&gt;★☆☆ 理解存储过程、触发器等作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-2-系统原理&#34;&gt;4.2 系统原理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ ACID 的作用以及实现原理。&lt;/li&gt;
&lt;li&gt;★★★ 四大隔离级别，以及不可重复读和幻影读的出现原因。&lt;/li&gt;
&lt;li&gt;★★☆ 封锁的类型以及粒度，两段锁协议，隐式和显示锁定。&lt;/li&gt;
&lt;li&gt;★★★ 乐观锁与悲观锁。&lt;/li&gt;
&lt;li&gt;★★★ MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读。&lt;/li&gt;
&lt;li&gt;★★☆ 范式理论。&lt;/li&gt;
&lt;li&gt;★★★ SQL 与 NoSQL 的比较。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-3-mysql&#34;&gt;4.3 MySQL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ B+ Tree 原理，与其它查找树的比较。&lt;/li&gt;
&lt;li&gt;★★★ MySQL 索引以及优化。&lt;/li&gt;
&lt;li&gt;★★★ 查询优化。&lt;/li&gt;
&lt;li&gt;★★★ InnoDB 与 MyISAM 比较。&lt;/li&gt;
&lt;li&gt;★★☆ 水平切分与垂直切分。&lt;/li&gt;
&lt;li&gt;★★☆ 主从复制原理、作用、实现。&lt;/li&gt;
&lt;li&gt;★☆☆ redo、undo、binlog 日志的作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-4-redis&#34;&gt;4.4 Redis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 字典和跳跃表原理分析。&lt;/li&gt;
&lt;li&gt;★★★ 使用场景。&lt;/li&gt;
&lt;li&gt;★★★ 与 Memchached 的比较。&lt;/li&gt;
&lt;li&gt;★☆☆ 数据淘汰机制。&lt;/li&gt;
&lt;li&gt;★★☆ RDB 和 AOF 持久化机制。&lt;/li&gt;
&lt;li&gt;★★☆ 事件驱动模型。&lt;/li&gt;
&lt;li&gt;★☆☆ 主从复制原理。&lt;/li&gt;
&lt;li&gt;★★★ 集群与分布式。&lt;/li&gt;
&lt;li&gt;★★☆ 事务原理。&lt;/li&gt;
&lt;li&gt;★★★ 线程安全问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🎨&lt;/p&gt;

&lt;h1 id=&#34;5-面向对象&#34;&gt;5. 面向对象&lt;/h1&gt;

&lt;h2 id=&#34;5-1-思想&#34;&gt;5.1 思想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ 面向对象三大特性&lt;/li&gt;
&lt;li&gt;★☆☆ 设计原则&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-2-设计模式&#34;&gt;5.2 设计模式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 设计模式的作用。&lt;/li&gt;
&lt;li&gt;★★★ 手写单例模式，特别是双重检验锁以及静态内部类。&lt;/li&gt;
&lt;li&gt;★★★ 手写工厂模式。&lt;/li&gt;
&lt;li&gt;★★★ 理解 MVC，结合 SpringMVC 回答。&lt;/li&gt;
&lt;li&gt;★★★ 理解代理模式，结合 Spring 中的 AOP 回答。&lt;/li&gt;
&lt;li&gt;★★★ 分析 JDK 中常用的设计模式，例如装饰者模式、适配器模式、迭代器模式等。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>反转整数</title>
      <link>https://linchengLC.github.io/post/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
      <pubDate>Fri, 18 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
      
        <description>&lt;p&gt;给定一个 32 位有符号整数，将整数中的数字进行反转。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 123&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 321&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; -123&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; -321&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 120&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 21&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31 ,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现思路:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1.如果x为负数则将标志位sign置为-1，并且将x变为正数&lt;/p&gt;

&lt;p&gt;2.for循环&lt;/p&gt;

&lt;p&gt;对x取10余得到temp&lt;/p&gt;

&lt;p&gt;放入res头内res*10+temp&lt;/p&gt;

&lt;p&gt;将x去除末尾&lt;/p&gt;

&lt;p&gt;3.还原x的符号到res&lt;/p&gt;

&lt;p&gt;4.处理res的溢出问题，使用math.maxint32和math.minint32&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;代码实现:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Reverse Integer
 * 反转整数
*/
import (
	“math”
)
func reverse(x int) int {
	sign := 1
	// 处理负数
	if x &amp;lt; 0 {
		sign = -1
		x = -1 * x
	}
	res := 0
	for x &amp;gt; 0 {
		// 取出x的末尾
		temp := x % 10
		// 放入 res 的开头
		res = res*10 + temp
		// x 去除末尾
		x = x / 10
	}
	// 还原 x 的符号到 res
	res = sign * res
	// 处理 res 的溢出问题
	if res &amp;gt; math.MaxInt32 || res &amp;lt; math.MinInt32 {
		res = 0
	}
	return res
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>罗马数字转换为整数</title>
      <link>https://linchengLC.github.io/post/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0/</link>
      <pubDate>Fri, 18 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0/</guid>
      
        <description>&lt;p&gt;罗马数字包含以下七种字符： I ， V ， X ， L ， C ， D 和 M 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符&lt;/strong&gt;  &lt;strong&gt;数值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I 1&lt;/p&gt;

&lt;p&gt;V 5&lt;/p&gt;

&lt;p&gt;X 10&lt;/p&gt;

&lt;p&gt;L 50&lt;/p&gt;

&lt;p&gt;C 100&lt;/p&gt;

&lt;p&gt;D 500&lt;/p&gt;

&lt;p&gt;M 1000&lt;/p&gt;

&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII , 即为 XX + V + II 。&lt;/p&gt;

&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII ，而是 IV 。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX 。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。&lt;/li&gt;
&lt;li&gt;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;III&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;IV&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 4&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;IX&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 9&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 4:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;LVIII&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 58&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解释:&lt;/strong&gt; C = 100, L = 50, XXX = 30, III = 3.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 5:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;MCMXCIV&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 1994&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解释:&lt;/strong&gt; M = 1000, CM = 900, XC = 90, IV = 4.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现思路:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1.定义一个map用于存储每个罗马数字代表的整数&lt;/p&gt;

&lt;p&gt;2.定义一个sign标志用于判断前一个罗马数字是否小于后一个罗马数字，如果小于则将sign标志置为-1&lt;/p&gt;

&lt;p&gt;3.从后往前循环遍历字符串，如果前一个罗马数字通过map获取到的值(temp)小于后一个(last)，sign=-1&lt;/p&gt;

&lt;p&gt;​    res=sign*temp&lt;/p&gt;

&lt;p&gt;​    last=temp&lt;/p&gt;

&lt;p&gt;4.返回res&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;代码实现:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Roman to Integer
 * 罗马数字转整数
*/
func romanToInt(s string) int {
	res := 0
	m := map[byte]int{
		‘I’: 1,
		‘V’: 5,
		‘X’: 10,
		‘L’: 50,
		‘C’: 100,
		‘D’: 500,
		‘M’: 1000,
	}
	last := 0
	for i := len(s) - 1; i &amp;gt;= 0; i— {
		temp := m[s[i]]
		sign := 1
		if temp &amp;lt; last {
			//小数在大数的左边，要减去小数
			sign = -1
		}
		res += sign * temp
		last = temp
	}
    return res
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>About</title>
      <link>https://linchengLC.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;

&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title></title>
      <link>https://linchengLC.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://linchengLC.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      
        <description>

&lt;p&gt;title: &amp;ldquo;MySQL学习笔记&amp;rdquo;
date: 2019-10-23T12:11:17+08:00
draft: false
tags: [&amp;ldquo;MySQL&amp;rdquo;]
categories: [&amp;ldquo;MySQL&amp;rdquo;]
author: &amp;ldquo;靖多多&amp;rdquo;&lt;/p&gt;

&lt;p&gt;weight: 1&lt;/p&gt;

&lt;h1 id=&#34;you-can-also-close-false-or-open-true-something-for-this-content&#34;&gt;You can also close(false) or open(true) something for this content.&lt;/h1&gt;

&lt;h1 id=&#34;p-s-comment-can-only-be-closed&#34;&gt;P.S. comment can only be closed&lt;/h1&gt;

&lt;h1 id=&#34;comment-false&#34;&gt;comment: false&lt;/h1&gt;

&lt;h1 id=&#34;toc-false&#34;&gt;toc: false&lt;/h1&gt;

&lt;h1 id=&#34;you-can-also-define-another-contentcopyright-e-g-contentcopyright-this-is-another-copyright&#34;&gt;You can also define another contentCopyright. e.g. contentCopyright: &amp;ldquo;This is another copyright.&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;contentCopyright: &amp;lsquo;&lt;a href=&#34;https://github.com/gohugoio/hugoBasicExample&#34; rel=&#34;noopener&#34; target=&#34;_blank&#34;&gt;See origin&lt;/a&gt;&amp;lsquo;&lt;/p&gt;

&lt;h1 id=&#34;reward-false&#34;&gt;reward: false&lt;/h1&gt;

&lt;p&gt;mathjax: true&lt;/p&gt;

&lt;h3 id=&#34;常用mysql命令&#34;&gt;常用mysql命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装：

&lt;ol&gt;
&lt;li&gt;Linux 系统联网&lt;/li&gt;
&lt;li&gt;sudo apt-get update&lt;/li&gt;
&lt;li&gt;sudo apt-get install mysql-server&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;启动：

&lt;ol&gt;
&lt;li&gt;/etc/init.d/mysql  start/stop/restart&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;service mysql start/stop/restart&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;mysql -V 查看版本&lt;/li&gt;
&lt;li&gt;service mysql status  查看当前mysql服务器运行状态。&lt;/li&gt;
&lt;li&gt;netstat -apn | grep mysql  查看当前mysql服务器进程（守护进程）信息。 端口：3306&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;登录：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;语法：mysql -h IP地址 -P 端口号 -u 用户名 -p密码&lt;/li&gt;
&lt;li&gt;mysql -h 127.0.0.1 -P 3306 -u root -p123456&lt;/li&gt;
&lt;li&gt;mysql  -u root -p123456  登录本地数据库。 明文密码输入。&lt;/li&gt;
&lt;li&gt;mysql  -u root -p 回车。  隐藏密码输入。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;一-模糊查询&#34;&gt;一：模糊查询&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;like&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;一般和通配符搭配使用&lt;/p&gt;

&lt;p&gt;​                通配符：&lt;/p&gt;

&lt;p&gt;​                %   任意多个字符，包含0个字符&lt;/p&gt;

&lt;p&gt;​                _   任意单个字符&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;between and&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;is null | is not null&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;1-like&#34;&gt;1）LIKE&lt;/h4&gt;

&lt;h5 id=&#34;案例1&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名字中包含字符a的员工信息&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select *
from employees
where last_name like &#39;%a%&#39;;#abc
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例2&#34;&gt;案例2&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名字中第三个字符为e，第五个字母为a的员工名和工资&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select last_name,salary
from employees
where last_name like &#39;__e_a%&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例3&#34;&gt;案例3&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名中第二个字符为_的员工名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select last_name
from employees
where last_name like &#39;_\_%&#39;;
(where last_name like &#39;_$_%&#39; escape &#39;$&#39;(声明$为转义字符))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-between-and&#34;&gt;2）between and&lt;/h4&gt;

&lt;h5 id=&#34;案例1-1&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工编号在100到120之间的员工信息&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select *
from employees
where employee_id between 100 and 120;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-in&#34;&gt;3）in&lt;/h4&gt;

&lt;h5 id=&#34;案例1-2&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工的工种编号是IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select last_name,job_id
from employees
where job_id in(&#39;IT_PROG&#39;,&#39;AD_VP&#39;,&#39;AD_PRES&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-is-null-is-not-null&#34;&gt;4）is null | is not null&lt;/h4&gt;

&lt;h5 id=&#34;案例1-3&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询没有奖金的员工名和奖金率&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select last_name,comission_pct
from employees
where commission_pct is null;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-安全等于-不等于&#34;&gt;5）安全等于&amp;lt;=&amp;gt;、不等于&amp;lt;&amp;gt;&lt;/h4&gt;

&lt;p&gt;&amp;lt;=&amp;gt;既可以判断null值，也可以判断普通的数值，可读性较低&lt;/p&gt;

&lt;h5 id=&#34;案例1-4&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询没有奖金的员工名和奖金率&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select last_name,comission_pct
from employees
where commission_pct &amp;lt;=&amp;gt; null;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;二-常用函数&#34;&gt;二、常用函数&lt;/h3&gt;

&lt;h4 id=&#34;1-concat函数&#34;&gt;1）concat函数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;拼接字符&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select concat(字符1，字符2，字符3，....);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-distinct&#34;&gt;2）distinct&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;去重&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct 字段名 from 表名
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-ifnull&#34;&gt;3）ifnull&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;判断某字段或表达式是否为null，如果为null返回指定的值，否则返回原本的值&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select ifnull(commission_pct,0) from employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-isnull&#34;&gt;4）isnull&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;判断某个字段或表达式是否为null，如果是，则返回1，否则返回0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;三-排序查询&#34;&gt;三、排序查询&lt;/h3&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 查询列表
from 表
【where 筛选条件】
order by 排序列表 【desc|asc】
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例1-5&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工信息，要求工资从高到低排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * 
from employees 
order by salary desc;
(默认不写为升序)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例2-1&#34;&gt;案例2&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询部门编号&amp;gt;=90的员工信息，按入职时间的先后进行排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * 
from employees 
where department_id&amp;gt;=90
order by hiredate asc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例3-1&#34;&gt;案例3&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;按年薪的高低显示员工的信息和年薪【按表达式排序】&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select *,salary*12*(1+ifnull(commission_pct,0)) 年薪
from employees
order by 年薪 desc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例4&#34;&gt;案例4&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;按姓名的长度显示员工的姓名和工资【按函数排序】&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select length(last_name) 字节长度,last_name,salary
from employees
order by length(last_name) desc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例5&#34;&gt;案例5&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工信息，要求先按工资排序，再按员工编号排序【按多个字段排序】&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * 
from employees
order by salary asc,job_id desc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;四-单行函数&#34;&gt;四、单行函数&lt;/h3&gt;

&lt;h4 id=&#34;1-字符函数&#34;&gt;1）字符函数&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;length  获取参数值的字节个数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select length(&#39;john&#39;);
   结果：4
   select length(&#39;张三丰haha&#39;);
   结果：13
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;concat 拼接字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select concat(last_name,&#39;_&#39;,first_name)
   from employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;upper、lower&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select upper(&#39;john&#39;);
   select lower(&#39;joHn&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：将姓变大写，名变小写，然后拼接&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select concat(upper(last_name),lower(first_name)) 姓名 
   from employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;substr、substring 截取字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：sql中索引从1开始&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;截取从指定索引处后面所有字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select substr(&#39;李莫愁爱上了陆展元&#39;,7) out_put;
   结果：陆展元
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;截取从指定索引处指定字符长度的字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select substr(&#39;李莫愁爱上了陆展元&#39;,1,3) out_put;
   结果：李莫愁
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select concat(upper(substr(last_name,1,1)),&#39;_&#39;,lower(substr(last_name,2)))
   from employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;instr 返回子串第一次出现起始索引，如果找不到返回0&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select instr(&#39;杨不殷六侠梅爱上了殷六侠&#39;,&#39;殷六侠&#39;) as out_put;
   结果：10
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;trim 去除前后空格&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select trim(&#39;  张翠山   &#39;) as out_put;
   结果：张翠山
   select trim(&#39;a&#39; from &#39;aaaaaaaa张aaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaa&#39;) as out_put;
   结果：张aaaaaaa翠山
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;lpad 用指定的字符实现左填充指定长度&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select lpad(&#39;殷素素&#39;,10,&#39;*&#39;) as out_put;
   结果：*******殷素素(加上殷素素为10)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;replace 替换&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select replace(&#39;张无忌爱上了周芷若&#39;,&#39;周芷若&#39;,&#39;赵敏&#39;) as out_put;
   结果：张无忌爱上了赵敏
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-数学函数&#34;&gt;2）数学函数&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;round 四舍五入&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select round(-1.55);
   结果：-2
   select round(1.567,2);
   结果：1.57
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;ceil 向上取整，返回&amp;gt;=该参数的最小整数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select ceil(-1.02);
   结果：-1
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;floor 向下取整，返回&amp;lt;=该参数的最大整&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select floor(-9.99);
   结果：-10
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;truncate 截断&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select truncate(1.6999,1);
   结果：1.6
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;mod 取余&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select mod(10,-3);
   结果：1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-日期函数&#34;&gt;3）日期函数&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;now 返回当前系统日期+时间&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select now();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;curdate 返回当前系统日期，不包含时间&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select curdate();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;curtime 返回当前系统时间，不包含日期&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select curtime();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;可以获取指定的部分，年、月、日、小时、分钟、秒&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select YEAR(NOW()) 年;  
   select YEAR(&#39;1998-1-1&#39;) 年;
   select YEAR(hiredata) 年 from employees;
   select MONTHNAME(NOW()) 月;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;str_to_date 将字符通过指定的格式转换成日期&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select str_to_date(&#39;1998-3-2&#39;,&#39;%Y-%c-%d&#39;) as out_put;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例：查询入职日期为1992-4-3的员工信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select * from employees where hiredate=&#39;1992-4-3&#39;
   实际业务场景：
   查询日期输入的不一定是按照数据库内保存数据格式相同输入的
   select * from employess where hiredate=str_to_date(&#39;4-3 1992&#39;,&#39;%c-%d %Y&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;date_format 将日期转换成字符&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select DATE_FORMAT(now(),&#39;%y年%m月%d日&#39;) as out_put
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例：查询有奖金的员工名和入职日期(xx月/xx日 xx年)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select last_name,DATE_FORMAT(hiredate,&#39;%m月%d日 %y年&#39;) 入职日期
   from employees
   where commission_pct is not null
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-流程控制函数&#34;&gt;4）流程控制函数&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;if函数 if else的效果&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select if(10&amp;lt;5,&#39;大&#39;,&#39;小&#39;)
   select last_name,commission_pct,IF(commission_pct is null,&#39;没奖金，呵呵&#39;,&#39;有奖金，嘻嘻&#39;);
   结果：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/19131697-3efe4072ad166502.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;case函数的使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;效果1：类似于switch case&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   case 要判断的字段或表达式
   when 常量1 then 要显示的值1或语句1
   when 常量2 then 要显示的值2或语句2
   ...
   else 要显示的值n或语句n
   end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例：查询员工的工资，要求&lt;/p&gt;

&lt;p&gt;​    部门号=30，显示的工资为1.1倍&lt;/p&gt;

&lt;p&gt;​    部门号=40，显示的工资为1.2倍&lt;/p&gt;

&lt;p&gt;​    部门号=50，显示的工资为1.3倍&lt;/p&gt;

&lt;p&gt;​    其他部门，显示的工资为原工资&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select salary 原始工资,department_id,
   case department_id
   when 30 then salary*1.1
   when 40 then salary*1.2
   when 50 then salary*1.3
   else salary
   end as 新工资
   from employess
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果2：类似于多重if&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   case 
   when 常量1 then 要显示的值1或语句1
   when 常量2 then 要显示的值2或语句2
   ...
   else 要显示的值n或语句n
   end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例：查询员工的工资情况&lt;/p&gt;

&lt;p&gt;​    如果工资&amp;gt;20000，显示A级别&lt;/p&gt;

&lt;p&gt;​    如果工资&amp;gt;15000，显示B级别&lt;/p&gt;

&lt;p&gt;​    如果工资&amp;gt;10000，显示C级别&lt;/p&gt;

&lt;p&gt;​    否则，显示D级别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select salary,
   case 
   when salary&amp;gt;20000 then &#39;A&#39;
   when salary&amp;gt;15000 then &#39;B&#39;
   when salary&amp;gt;10000 then &#39;C&#39;
   else &#39;D&#39;
   end as 工资级别
   from employess
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;五-分组函数&#34;&gt;五、分组函数&lt;/h3&gt;

&lt;p&gt;SUM、AVG、MAX、MIN、COUNT&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;​   1、sum、avg一般用于处理数值型&lt;/p&gt;

&lt;p&gt;​         max、min、count可以处理任何类型&lt;/p&gt;

&lt;p&gt;​   2、以上分组函数都忽略null值&lt;/p&gt;

&lt;p&gt;​   3、可以和distinct搭配实现去重的运算&lt;/p&gt;

&lt;p&gt;​   4、count函数的详细介绍&lt;/p&gt;

&lt;p&gt;​         一般使用count(*)用作统计行数&lt;/p&gt;

&lt;p&gt;​   5、和分组函数一同查询的字段要求是group by后的字段&lt;/p&gt;

&lt;h4 id=&#34;1-简单使用&#34;&gt;1）简单使用&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select SUM(salary) FROM employees;
select AVG(salary) FROM employees;
select MIN(salary) FROM employees;
select MAX(salary) FROM employees;
select COUNT(salary) FROM employees;

select SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数 FROM employees;

select SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数 FROM employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-参数支持哪些类型&#34;&gt;2）参数支持哪些类型&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select SUM(last_name),AVG(last_name) FROM emloyees;
select SUM(hiredate),AVG(hiredate) FROM emloyees;
上述两种无意义

select MAX(last_name),MIN(last_name) FROM emloyees;
select MAX(hiredate),MIN(hiredate) FROM emloyees;

select COUNT(commission_pct) FROM employees;
select COUNT(last_name) FROM employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-忽略null值&#34;&gt;3）忽略null值&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select SUM(commission_pct),AVG(commission_pct) FROM emloyees;
select COUNT(commission_pct) FROM employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-和distinct搭配&#34;&gt;4）和distinct搭配&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select SUM(DISTINCT salary),SUM(salary) FROM employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-count函数的详细介绍&#34;&gt;5）COUNT函数的详细介绍&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select COUNT(*) FROM employees;		#经常用于统计行数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效率：&lt;/p&gt;

&lt;p&gt;MYISAM存储引擎下，COUNT(*)的效率高&lt;/p&gt;

&lt;p&gt;INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些（原因：如果是字段需要先判断是否为null，不为才加1，因此效率相对较低）&lt;/p&gt;

&lt;h3 id=&#34;六-分组查询&#34;&gt;六、分组查询&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;​       select 分组函数，列（要求出现在group by的后面）&lt;/p&gt;

&lt;p&gt;​       from 表&lt;/p&gt;

&lt;p&gt;​     【where 筛选条件】&lt;/p&gt;

&lt;p&gt;​       group by 分组的列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【order by 子句】
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;​       查询列表必须特殊，要求是分组函数和group by后出现的字段&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;​       1、分组查询中的筛选条件分为两类&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;数据源&lt;/th&gt;
&lt;th&gt;位置&lt;/th&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;分组前筛选&lt;/td&gt;
&lt;td&gt;原始表&lt;/td&gt;
&lt;td&gt;group by子句的前面&lt;/td&gt;
&lt;td&gt;where&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;分组后筛选&lt;/td&gt;
&lt;td&gt;分组后的结果集&lt;/td&gt;
&lt;td&gt;group by子句的后面&lt;/td&gt;
&lt;td&gt;having&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;​       ①分组函数做条件肯定是放在having子句&lt;/p&gt;

&lt;p&gt;​       ②能用分组前筛选的，优先考虑使用分组前筛选&lt;/p&gt;

&lt;p&gt;​       2、group by子句支持单个字段分组，多个字段分组（多个字段之间用逗号隔开没有顺序要求），表达式或函数（用的较少）&lt;/p&gt;

&lt;p&gt;​       3、也可以添加排序（排序放在整个分组查询最后）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引入：查询每个部门的平均工资&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select AVG(salary) FROM employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例1-6&#34;&gt;案例1：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个工种的最高工资&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select MAX(salary),job_id
  FROM employees
  GROUP BY job_id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例2-2&#34;&gt;案例2：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个位置上的部门个数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select COUNT(*),location_id
  FROM departments
  GROUP BY location_id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例3-2&#34;&gt;案例3：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询邮箱中包含a字符的，每个部门的平均工资&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select AVG(salary),deparment_id
  FROM employees
  WHERE email LIKE &#39;%a%&#39;
  GROUP BY deparment_id
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例4-1&#34;&gt;案例4：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询有奖金的每个领导手下员工的最高工资&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select MAX(salary),manager_id
  FROM employees
  WHERE commission_pct IS NOT NULL
  GROUP BY manager_id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例5-1&#34;&gt;案例5：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询哪个部门的员工个数&amp;gt;2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①查询每个部门的员工个数&lt;/p&gt;

&lt;p&gt;②根据①的结果进行筛选，查询哪个部门的员工个数&amp;gt;2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select COUNT(*),department_id
  FROM employees
  GROUP BY department_id
  HAVING COUNT(*)&amp;gt;2;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例6&#34;&gt;案例6：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个工种有奖金的员工的最高工资&amp;gt;12000的工种编号和最高工资&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①查询每个工种有奖金的员工的最高工资&lt;/p&gt;

&lt;p&gt;②根据①结果继续筛选，最高工资&amp;gt;12000&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select job_id,MAX(salary)
  FROM employees
  WHERE commission_pct IS NOT NULL
  GROUP BY job_id
  HAVING MAX(salary)&amp;gt;12000;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例7&#34;&gt;案例7：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询领导编号&amp;gt;102的每个领导手下最低工资&amp;gt;5000的领导编号是哪个，以及其最低工资&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①查询每个领导手下的员工固定最低工资&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select manager_id,MIN(salary)
  FROM employees
  GROUP BY manager_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②添加筛选条件，编号&amp;gt;102&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select manager_id,MIN(salary)
  FROM employees
  WHERE manager_id&amp;gt;102		#manager_id在employees表里，因此放在group by前面
  GROUP BY manager_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③添加筛选条件，最低工资&amp;gt;5000&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select manager_id,MIN(salary)
  FROM employees
  WHERE manager_id&amp;gt;102		#manager_id在employees表里，因此放在group by前面
  GROUP BY manager_id
  HAVING MIN(salary)&amp;gt;5000
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;按表达式或函数分组&#34;&gt;按表达式或函数分组&lt;/h4&gt;

&lt;h5 id=&#34;案例8&#34;&gt;案例8：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&amp;gt;5的有哪些&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①查询每个长度的员工个数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select COUNT(*),LENGTH(last_name) len_name
  FROM employees
  GROUP BY LENGTH(last_name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②添加筛选条件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select COUNT(*),LENGTH(last_name) len_name
  FROM employees
  GROUP BY LENGTH(last_name)
  HAVING COUNT(*)&amp;gt;5;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;按多个字段分组&#34;&gt;按多个字段分组&lt;/h4&gt;

&lt;h5 id=&#34;案例9&#34;&gt;案例9：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个部门每个工种的员工的平均工资&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select AVG(salary),department_id,job_id
  FROM employees
  GROUP BY department_id,job_id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;添加排序&#34;&gt;添加排序&lt;/h4&gt;

&lt;h5 id=&#34;案例10&#34;&gt;案例10：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个部门每个工种的员工的平均工资，并且按平均工资的高低显示&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select AVG(salary),department_id,job_id
  FROM employees
  GROUP BY department_id,job_id
  HAVING AVG(salary)&amp;gt;10000
  ORDER BY AVG(salary) DESC;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;七-连接查询&#34;&gt;七、连接查询&lt;/h3&gt;

&lt;p&gt;含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询&lt;/p&gt;

&lt;p&gt;笛卡尔乘积现象：表1有m行，表2有n行，结果=m*n行&lt;/p&gt;

&lt;p&gt;发生原因：没有有效的连接条件&lt;/p&gt;

&lt;p&gt;如何避免：添加有效的连接条件&lt;/p&gt;

&lt;p&gt;分类：&lt;/p&gt;

&lt;p&gt;​       内连接：&lt;/p&gt;

&lt;p&gt;​                   等值连接&lt;/p&gt;

&lt;p&gt;​                   非等值连接&lt;/p&gt;

&lt;p&gt;​                   自连接&lt;/p&gt;

&lt;p&gt;​       外连接：&lt;/p&gt;

&lt;p&gt;​                   左外连接&lt;/p&gt;

&lt;p&gt;​                   右外连接&lt;/p&gt;

&lt;p&gt;​                   全外连接&lt;/p&gt;

&lt;p&gt;​       交叉连接&lt;/p&gt;

&lt;h4 id=&#34;1-等值连接&#34;&gt;1、等值连接&lt;/h4&gt;

&lt;h5 id=&#34;案例1-7&#34;&gt;案例1：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询女神名和对应的男神名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select name,boyName 
  From boys,beauty
  where beauty.boyfriend_id=boys.id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例2-3&#34;&gt;案例2：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名和对应的部门名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select last_name,department_name
  FROM employees,departments
  WHERE employees.&#39;department_id&#39;=departments.&#39;department_id&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例3-3&#34;&gt;案例3：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名、工种号、工种名(起别名)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select last_name,employees.job_id,job_title
  FROM employees,jobs
  where employees.&#39;job_id&#39;=jobs.&#39;job_id&#39;;
  
  select last_name,e.job_id,job_title
  FROM employees as e,jobs as j
  where e.&#39;job_id&#39;=j.&#39;job_id&#39;;
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
  </channel>
</rss>
