<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>lin&#39;s blog</title>
    <link>https://linchengLC.github.io/</link>
    <description>Recent content on lin&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 28 Nov 2019 12:11:17 +0800</lastBuildDate>
    
        <atom:link href="https://linchengLC.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>标准库Flag基本使用</title>
      <link>https://linchengLC.github.io/post/flag/</link>
      <pubDate>Thu, 28 Nov 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/flag/</guid>
      
        <description>

&lt;p&gt;Go语言内置的&lt;code&gt;flag&lt;/code&gt;包实现了命令行参数的解析，&lt;code&gt;flag&lt;/code&gt;包使得开发命令行工具更为简单。&lt;/p&gt;

&lt;h1 id=&#34;os-args&#34;&gt;os.Args&lt;/h1&gt;

&lt;p&gt;如果你只是简单的想要获取命令行参数，可以像下面的代码示例一样使用&lt;code&gt;os.Args&lt;/code&gt;来获取命令行参数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

//os.Args demo
func main() {
	//os.Args是一个[]string
	if len(os.Args) &amp;gt; 0 {
		for index, arg := range os.Args {
			fmt.Printf(&amp;quot;args[%d]=%v\n&amp;quot;, index, arg)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将上面的代码执行&lt;code&gt;go build -o &amp;quot;args_demo&amp;quot;&lt;/code&gt;编译之后，执行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./args_demo a b c d
args[0]=./args_demo
args[1]=a
args[2]=b
args[3]=c
args[4]=d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;os.Args&lt;/code&gt;是一个存储命令行参数的字符串切片，它的第一个元素是执行文件的名称。&lt;/p&gt;

&lt;h1 id=&#34;flag包基本使用&#34;&gt;flag包基本使用&lt;/h1&gt;

&lt;p&gt;本文介绍了flag包的常用函数和基本用法，更详细的内容请查看&lt;a href=&#34;https://studygolang.com/pkgdoc&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;导入flag包&#34;&gt;导入flag包&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import flag
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flag参数类型&#34;&gt;flag参数类型&lt;/h2&gt;

&lt;p&gt;flag包支持的命令行参数类型有&lt;code&gt;bool&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;int64&lt;/code&gt;、&lt;code&gt;uint&lt;/code&gt;、&lt;code&gt;uint64&lt;/code&gt;、&lt;code&gt;float&lt;/code&gt; &lt;code&gt;float64&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;duration&lt;/code&gt;。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;flag参数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;有效值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;字符串flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;合法字符串&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;整数flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1234、0664、0x1234等类型，也可以是负数。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;浮点数flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;合法浮点数&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;bool类型flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1, 0, t, f, T, F, true, false, TRUE, FALSE, True, False。&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;时间段flag&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;任何合法的时间段字符串。如”300ms”、”-1.5h”、”2h45m”。 合法的单位有”ns”、”us” /“µs”、”ms”、”s”、”m”、”h”。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;定义命令行flag参数&#34;&gt;定义命令行flag参数&lt;/h2&gt;

&lt;p&gt;有以下两种常用的定义命令行&lt;code&gt;flag&lt;/code&gt;参数的方法。&lt;/p&gt;

&lt;h3 id=&#34;flag-type&#34;&gt;flag.Type()&lt;/h3&gt;

&lt;p&gt;基本格式如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;flag.Type(flag名, 默认值, 帮助信息)*Type&lt;/code&gt; 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func FlagDemo1()  {
	name:=flag.String(&amp;quot;name&amp;quot;,&amp;quot;张三&amp;quot;,&amp;quot;姓名&amp;quot;)
	age:=flag.Int(&amp;quot;age&amp;quot;,18,&amp;quot;年龄&amp;quot;)
	married:=flag.Bool(&amp;quot;married&amp;quot;,false,&amp;quot;婚否&amp;quot;)
	delay:=flag.Duration(&amp;quot;d&amp;quot;,0,&amp;quot;时间间隔&amp;quot;)
	flag.Parse()
	fmt.Println(*name,*age,*married,*delay)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意的是，此时&lt;code&gt;name&lt;/code&gt;、&lt;code&gt;age&lt;/code&gt;、&lt;code&gt;married&lt;/code&gt;、&lt;code&gt;delay&lt;/code&gt;均为对应类型的指针。&lt;/p&gt;

&lt;p&gt;命令行调用:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-SHELL&#34;&gt;./flag_demo.exe -name=&amp;quot;豪杰&amp;quot; -age=18 -married=false -d=30s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打印结果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;豪杰 18 false 30s
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;flag-typevar&#34;&gt;flag.TypeVar()&lt;/h3&gt;

&lt;p&gt;基本格式如下： &lt;code&gt;flag.TypeVar(Type指针, flag名, 默认值, 帮助信息)&lt;/code&gt; 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func FlagDemo2()  {
	var(
		name string
		age int
		married bool
		delay time.Duration
	)
	flag.StringVar(&amp;amp;name,&amp;quot;name&amp;quot;,&amp;quot;张三丰&amp;quot;,&amp;quot;姓名&amp;quot;)
	flag.IntVar(&amp;amp;age,&amp;quot;age&amp;quot;,18,&amp;quot;年龄&amp;quot;)
	flag.BoolVar(&amp;amp;married,&amp;quot;married&amp;quot;,false,&amp;quot;婚否&amp;quot;)
	flag.DurationVar(&amp;amp;delay,&amp;quot;d&amp;quot;,0,&amp;quot;时间间隔&amp;quot;)
	flag.Parse()
	fmt.Println(name,age,married,delay)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;flag-parse&#34;&gt;flag.Parse()&lt;/h2&gt;

&lt;p&gt;通过以上两种方法定义好命令行flag参数后，需要通过调用&lt;code&gt;flag.Parse()&lt;/code&gt;来对命令行参数进行解析。&lt;/p&gt;

&lt;p&gt;支持的命令行参数格式有以下几种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-flag xxx&lt;/code&gt; （使用空格，一个&lt;code&gt;-&lt;/code&gt;符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--flag xxx&lt;/code&gt; （使用空格，两个&lt;code&gt;-&lt;/code&gt;符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-flag=xxx&lt;/code&gt; （使用等号，一个&lt;code&gt;-&lt;/code&gt;符号）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--flag=xxx&lt;/code&gt; （使用等号，两个&lt;code&gt;-&lt;/code&gt;符号）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，布尔类型的参数必须使用等号的方式指定。&lt;/p&gt;

&lt;p&gt;Flag解析在第一个非flag参数（单个”-“不是flag参数）之前停止，或者在终止符”–“之后停止。&lt;/p&gt;

&lt;h2 id=&#34;flag其他函数&#34;&gt;flag其他函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;flag.Args()  ////返回命令行参数后的其他参数，以[]string类型
flag.NArg()  //返回命令行参数后的其他参数个数
flag.NFlag() //返回使用的命令行参数个数
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;完整示例&#34;&gt;完整示例&lt;/h2&gt;

&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {
	//定义命令行参数方式1
	var name string
	var age int
	var married bool
	var delay time.Duration
	flag.StringVar(&amp;amp;name, &amp;quot;name&amp;quot;, &amp;quot;张三&amp;quot;, &amp;quot;姓名&amp;quot;)
	flag.IntVar(&amp;amp;age, &amp;quot;age&amp;quot;, 18, &amp;quot;年龄&amp;quot;)
	flag.BoolVar(&amp;amp;married, &amp;quot;married&amp;quot;, false, &amp;quot;婚否&amp;quot;)
	flag.DurationVar(&amp;amp;delay, &amp;quot;d&amp;quot;, 0, &amp;quot;延迟的时间间隔&amp;quot;)

	//解析命令行参数
	flag.Parse()
	fmt.Println(name, age, married, delay)
	fmt.Println(flag.Args())//返回命令行参数后的其他参数
	fmt.Println(flag.NArg())//返回命令行参数后的其他参数个数
	fmt.Println(flag.NFlag())//返回使用的命令行参数个数
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;

&lt;p&gt;命令行参数使用提示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./flag_demo -help
Usage of ./flag_demo:
  -age int
        年龄 (default 18)
  -d duration
        时间间隔
  -married
        婚否
  -name string
        姓名 (default &amp;quot;张三&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常使用命令行flag参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./flag_demo -name 沙河娜扎 --age 28 -married=false -d=1h30m
沙河娜扎 28 false 1h30m0s
[]
0
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用非flag命令行参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ./flag_demo a b c
张三 18 false 0s
[a b c]
3
0
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>Goroutine管理</title>
      <link>https://linchengLC.github.io/post/goroutine%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 28 Nov 2019 03:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/goroutine%E7%AE%A1%E7%90%86/</guid>
      
        <description>

&lt;h2 id=&#34;groutine分组管理-sync-waitgroup&#34;&gt;Groutine分组管理、sync、WaitGroup&lt;/h2&gt;

&lt;h4 id=&#34;一-sync-waitgroup-进行goroutine的控制&#34;&gt;一、sync.WaitGroup{}进行goroutine的控制&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;WaitGroup等待组是控制goroutine并发的一种方式，在我看来真正的意义是照顾弱势的“子goroutine”，通过Add()方法，确定预期要运行的goroutine的个数，然后goroutine内部通过defer延迟函数执行Done()方法，对一个goroutine运行结束后，进行计数减一，最后在“父goroutine”中的某个位置通过Wait()方法等待所有“子goroutine”执行结束，才能继续“父goroutine”的其他工作。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;示例代码如下：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;sync&amp;quot;
	&amp;quot;fmt&amp;quot;
)

func main() {

	var wg sync.WaitGroup

	fmt.Println(&amp;quot;Prepare get in goroutine&amp;quot;)

	wg.Add(1)
	go func() {
		defer wg.Done()
		fmt.Println(&amp;quot;I`m in a goroutine.&amp;quot;)
	}()

	fmt.Println(&amp;quot;out the goroutine.&amp;quot;)

	wg.Wait() // 等待main中的goroutine执行完，才能继续下去
	fmt.Println(&amp;quot;main is stopping&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;二-简陋地给goroutine的函数传channel值或通过作用域的channel变量进行控制&#34;&gt;二、简陋地给goroutine的函数传channel值或通过作用域的channel变量进行控制&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;通过给函数传递一个通道参数，再通过select的其中一个case进行该通道接收判定，如果收到值就会执行终止goroutine的操作。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;通过作用域的通道变量是指，该通道变量不是在goroutine中声明的，换句话说是在该goroutine外面对声明的这个通道变量进行传值操作，会对该goroutine中这个通道变量的case判定造成接收，进而可以执行终止goroutine的操作。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下面是通过goroutine的函数参数传值进行控制的方式。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {

	ch := make(chan struct{})
	go printSomething(ch)

	time.Sleep(5*time.Second)
	close(ch)
	time.Sleep(10*time.Second)

}

func printSomething(ch chan struct{}) {
	ticker := time.NewTicker(3*time.Second)
	for {
		select {
		case &amp;lt;-ch:
			fmt.Println(&amp;quot;finished printing work by channel&amp;quot;)
			return
		case &amp;lt;-ticker.C:
			fmt.Println(&amp;quot;finished printing work by time.Ticker&amp;quot;)
			return
		default:
			time.Sleep(time.Second)
			fmt.Println(&amp;quot;Hello World.&amp;quot;)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面的示例是在一个作用域下通过通道传值影响到goroutine内的这个等待传值的通道来控制goroutine的方式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)

func main() {
	ch := make(chan bool)

	go func() {
		for {
			select {
			case &amp;lt;-ch:
				fmt.Println(&amp;quot;stop the goroutine...&amp;quot;)
				return
			default:
				time.Sleep(time.Second)
				fmt.Println(&amp;quot;Doria`s sheep is eating grass.&amp;quot;)
			}
		}
	}()

	time.Sleep(5*time.Second)
	ch &amp;lt;- true

}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;三-context进行goroutine的控制&#34;&gt;三、context进行goroutine的控制&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;context实现对goroutine的控制是通过该context的对象的取消函数对应的Done()函数，即一个struct{}类型的通道，当执行WithCancel()函数，会返回一个cancelFunc，当执行该函数时，会通知goroutine中的ctx.Done()函数，然后可以借此进行goroutine的停止退出。另外衍生出的方法还有WithDeadline(),WithTimeout(),WithValue(),其中WithDeadline(),WithTimeout()的功能大致与WithCancel()差不多，只是多了一个截止时间参数，而WithValue()是通过传入的key和val，在goroutine中传入实参context，然后共享到这个context的key的val值。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package main

import (
	&amp;quot;context&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;time&amp;quot;
)
var lastName string = &amp;quot;lastName&amp;quot;

func main() {
	ctx, cancel := context.WithCancel(context.Background())
	ctxHasValue := context.WithValue(ctx, lastName, &amp;quot;Stark&amp;quot;)
	go sayHello(ctxHasValue, &amp;quot;Snow&amp;quot;)
	go sayHello(ctxHasValue, &amp;quot;Joe&amp;quot;)

	time.Sleep(5*time.Second)
	cancel()
	time.Sleep(5*time.Second)
	fmt.Println(&amp;quot;main ends...&amp;quot;)

}

func sayHello(ctx context.Context, name string) {
	for {
		select {
		case &amp;lt;-ctx.Done():
			fmt.Printf(&amp;quot;%s says: Goodbye, Arya %s...\n&amp;quot;, name, ctx.Value(lastName))
			return
		default:
			time.Sleep(time.Second)
			fmt.Printf(&amp;quot;Hello, Arya %s, I`m %s\n&amp;quot;, ctx.Value(lastName), name)
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;四-总结&#34;&gt;四、总结&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;简单总结一下，WaitGroup的作用是保证预期要执行的“子goroutine”都能执行到，而不被“父goroutine”欺负。而通过通道传值和context控制goroutine的停止，其实本质是没有太大区别的。但值得一提的是，前段时间在网上看过一篇文章，说Google公司的程序员写goroutine并发被要求并发函数的第一个参数需要是ctx context.Context，不论真假，至少说明了一件事，使用到context来控制goroutine是非常美观和方便的。在高并发的开发场景下，goroutine之间的通信和控制会变得异常艰难，如果使用到context，可以安全地停止goroutine，方便地进行通信操作。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Mysql学习笔记</title>
      <link>https://linchengLC.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 28 Nov 2019 03:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/mysql%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      
        <description>

&lt;h3 id=&#34;常用mysql命令&#34;&gt;常用mysql命令&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;安装：

&lt;ol&gt;
&lt;li&gt;Linux 系统联网&lt;/li&gt;
&lt;li&gt;sudo apt-get update&lt;/li&gt;
&lt;li&gt;sudo apt-get install mysql-server&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;启动：

&lt;ol&gt;
&lt;li&gt;/etc/init.d/mysql  start/stop/restart&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;service mysql start/stop/restart&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查看：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;mysql -V 查看版本&lt;/li&gt;
&lt;li&gt;service mysql status  查看当前mysql服务器运行状态。&lt;/li&gt;
&lt;li&gt;netstat -apn | grep mysql  查看当前mysql服务器进程（守护进程）信息。 端口：3306&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;登录：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;语法：mysql -h IP地址 -P 端口号 -u 用户名 -p密码&lt;/li&gt;
&lt;li&gt;mysql -h 127.0.0.1 -P 3306 -u root -p123456&lt;/li&gt;
&lt;li&gt;mysql  -u root -p123456  登录本地数据库。 明文密码输入。&lt;/li&gt;
&lt;li&gt;mysql  -u root -p 回车。  隐藏密码输入。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;一-模糊查询&#34;&gt;一：模糊查询&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;like&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;一般和通配符搭配使用&lt;/p&gt;

&lt;p&gt;​                通配符：&lt;/p&gt;

&lt;p&gt;​                %   任意多个字符，包含0个字符&lt;/p&gt;

&lt;p&gt;​                _   任意单个字符&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;between and&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;in&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;is null | is not null&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;1-like&#34;&gt;1）LIKE&lt;/h4&gt;

&lt;h5 id=&#34;案例1&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名字中包含字符a的员工信息&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select *
from employees
where last_name like &#39;%a%&#39;;#abc
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例2&#34;&gt;案例2&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名字中第三个字符为e，第五个字母为a的员工名和工资&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select last_name,salary
from employees
where last_name like &#39;__e_a%&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例3&#34;&gt;案例3&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名中第二个字符为_的员工名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select last_name
from employees
where last_name like &#39;_\_%&#39;;
(where last_name like &#39;_$_%&#39; escape &#39;$&#39;(声明$为转义字符))
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-between-and&#34;&gt;2）between and&lt;/h4&gt;

&lt;h5 id=&#34;案例1-1&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工编号在100到120之间的员工信息&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select *
from employees
where employee_id between 100 and 120;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-in&#34;&gt;3）in&lt;/h4&gt;

&lt;h5 id=&#34;案例1-2&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工的工种编号是IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select last_name,job_id
from employees
where job_id in(&#39;IT_PROG&#39;,&#39;AD_VP&#39;,&#39;AD_PRES&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-is-null-is-not-null&#34;&gt;4）is null | is not null&lt;/h4&gt;

&lt;h5 id=&#34;案例1-3&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询没有奖金的员工名和奖金率&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select last_name,comission_pct
from employees
where commission_pct is null;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-安全等于-不等于&#34;&gt;5）安全等于&amp;lt;=&amp;gt;、不等于&amp;lt;&amp;gt;&lt;/h4&gt;

&lt;p&gt;&amp;lt;=&amp;gt;既可以判断null值，也可以判断普通的数值，可读性较低&lt;/p&gt;

&lt;h5 id=&#34;案例1-4&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询没有奖金的员工名和奖金率&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select last_name,comission_pct
from employees
where commission_pct &amp;lt;=&amp;gt; null;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;二-常用函数&#34;&gt;二、常用函数&lt;/h3&gt;

&lt;h4 id=&#34;1-concat函数&#34;&gt;1）concat函数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;拼接字符&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select concat(字符1，字符2，字符3，....);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-distinct&#34;&gt;2）distinct&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;去重&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select distinct 字段名 from 表名
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-ifnull&#34;&gt;3）ifnull&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;判断某字段或表达式是否为null，如果为null返回指定的值，否则返回原本的值&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select ifnull(commission_pct,0) from employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-isnull&#34;&gt;4）isnull&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;判断某个字段或表达式是否为null，如果是，则返回1，否则返回0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;三-排序查询&#34;&gt;三、排序查询&lt;/h3&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select 查询列表
from 表
【where 筛选条件】
order by 排序列表 【desc|asc】
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例1-5&#34;&gt;案例1&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工信息，要求工资从高到低排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * 
from employees 
order by salary desc;
(默认不写为升序)
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例2-1&#34;&gt;案例2&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询部门编号&amp;gt;=90的员工信息，按入职时间的先后进行排序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * 
from employees 
where department_id&amp;gt;=90
order by hiredate asc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例3-1&#34;&gt;案例3&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;按年薪的高低显示员工的信息和年薪【按表达式排序】&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select *,salary*12*(1+ifnull(commission_pct,0)) 年薪
from employees
order by 年薪 desc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例4&#34;&gt;案例4&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;按姓名的长度显示员工的姓名和工资【按函数排序】&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select length(last_name) 字节长度,last_name,salary
from employees
order by length(last_name) desc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例5&#34;&gt;案例5&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工信息，要求先按工资排序，再按员工编号排序【按多个字段排序】&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select * 
from employees
order by salary asc,job_id desc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;四-单行函数&#34;&gt;四、单行函数&lt;/h3&gt;

&lt;h4 id=&#34;1-字符函数&#34;&gt;1）字符函数&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;length  获取参数值的字节个数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select length(&#39;john&#39;);
   结果：4
   select length(&#39;张三丰haha&#39;);
   结果：13
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;concat 拼接字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select concat(last_name,&#39;_&#39;,first_name)
   from employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;upper、lower&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select upper(&#39;john&#39;);
   select lower(&#39;joHn&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;示例：将姓变大写，名变小写，然后拼接&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select concat(upper(last_name),lower(first_name)) 姓名 
   from employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;substr、substring 截取字符串&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
&lt;p&gt;注意：sql中索引从1开始&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;截取从指定索引处后面所有字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select substr(&#39;李莫愁爱上了陆展元&#39;,7) out_put;
   结果：陆展元
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;截取从指定索引处指定字符长度的字符&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select substr(&#39;李莫愁爱上了陆展元&#39;,1,3) out_put;
   结果：李莫愁
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例：姓名中首字符大写，其他字符小写然后用_拼接，显示出来&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select concat(upper(substr(last_name,1,1)),&#39;_&#39;,lower(substr(last_name,2)))
   from employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;instr 返回子串第一次出现起始索引，如果找不到返回0&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select instr(&#39;杨不殷六侠梅爱上了殷六侠&#39;,&#39;殷六侠&#39;) as out_put;
   结果：10
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;trim 去除前后空格&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select trim(&#39;  张翠山   &#39;) as out_put;
   结果：张翠山
   select trim(&#39;a&#39; from &#39;aaaaaaaa张aaaaaaa翠山aaaaaaaaaaaaaaaaaaaaaaaa&#39;) as out_put;
   结果：张aaaaaaa翠山
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;lpad 用指定的字符实现左填充指定长度&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select lpad(&#39;殷素素&#39;,10,&#39;*&#39;) as out_put;
   结果：*******殷素素(加上殷素素为10)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;replace 替换&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select replace(&#39;张无忌爱上了周芷若&#39;,&#39;周芷若&#39;,&#39;赵敏&#39;) as out_put;
   结果：张无忌爱上了赵敏
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-数学函数&#34;&gt;2）数学函数&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;round 四舍五入&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select round(-1.55);
   结果：-2
   select round(1.567,2);
   结果：1.57
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;ceil 向上取整，返回&amp;gt;=该参数的最小整数&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select ceil(-1.02);
   结果：-1
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;floor 向下取整，返回&amp;lt;=该参数的最大整&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select floor(-9.99);
   结果：-10
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;truncate 截断&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select truncate(1.6999,1);
   结果：1.6
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;mod 取余&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select mod(10,-3);
   结果：1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-日期函数&#34;&gt;3）日期函数&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;now 返回当前系统日期+时间&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select now();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;curdate 返回当前系统日期，不包含时间&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select curdate();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;curtime 返回当前系统时间，不包含日期&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select curtime();
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;可以获取指定的部分，年、月、日、小时、分钟、秒&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select YEAR(NOW()) 年;  
   select YEAR(&#39;1998-1-1&#39;) 年;
   select YEAR(hiredata) 年 from employees;
   select MONTHNAME(NOW()) 月;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;str_to_date 将字符通过指定的格式转换成日期&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select str_to_date(&#39;1998-3-2&#39;,&#39;%Y-%c-%d&#39;) as out_put;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例：查询入职日期为1992-4-3的员工信息&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select * from employees where hiredate=&#39;1992-4-3&#39;
   实际业务场景：
   查询日期输入的不一定是按照数据库内保存数据格式相同输入的
   select * from employess where hiredate=str_to_date(&#39;4-3 1992&#39;,&#39;%c-%d %Y&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;date_format 将日期转换成字符&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select DATE_FORMAT(now(),&#39;%y年%m月%d日&#39;) as out_put
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例：查询有奖金的员工名和入职日期(xx月/xx日 xx年)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select last_name,DATE_FORMAT(hiredate,&#39;%m月%d日 %y年&#39;) 入职日期
   from employees
   where commission_pct is not null
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-流程控制函数&#34;&gt;4）流程控制函数&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;if函数 if else的效果&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select if(10&amp;lt;5,&#39;大&#39;,&#39;小&#39;)
   select last_name,commission_pct,IF(commission_pct is null,&#39;没奖金，呵呵&#39;,&#39;有奖金，嘻嘻&#39;);
   结果：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/19131697-3efe4072ad166502.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;case函数的使用&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;效果1：类似于switch case&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   case 要判断的字段或表达式
   when 常量1 then 要显示的值1或语句1
   when 常量2 then 要显示的值2或语句2
   ...
   else 要显示的值n或语句n
   end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例：查询员工的工资，要求&lt;/p&gt;

&lt;p&gt;​    部门号=30，显示的工资为1.1倍&lt;/p&gt;

&lt;p&gt;​    部门号=40，显示的工资为1.2倍&lt;/p&gt;

&lt;p&gt;​    部门号=50，显示的工资为1.3倍&lt;/p&gt;

&lt;p&gt;​    其他部门，显示的工资为原工资&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select salary 原始工资,department_id,
   case department_id
   when 30 then salary*1.1
   when 40 then salary*1.2
   when 50 then salary*1.3
   else salary
   end as 新工资
   from employess
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效果2：类似于多重if&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   case 
   when 常量1 then 要显示的值1或语句1
   when 常量2 then 要显示的值2或语句2
   ...
   else 要显示的值n或语句n
   end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;案例：查询员工的工资情况&lt;/p&gt;

&lt;p&gt;​    如果工资&amp;gt;20000，显示A级别&lt;/p&gt;

&lt;p&gt;​    如果工资&amp;gt;15000，显示B级别&lt;/p&gt;

&lt;p&gt;​    如果工资&amp;gt;10000，显示C级别&lt;/p&gt;

&lt;p&gt;​    否则，显示D级别&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;   select salary,
   case 
   when salary&amp;gt;20000 then &#39;A&#39;
   when salary&amp;gt;15000 then &#39;B&#39;
   when salary&amp;gt;10000 then &#39;C&#39;
   else &#39;D&#39;
   end as 工资级别
   from employess
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;五-分组函数&#34;&gt;五、分组函数&lt;/h3&gt;

&lt;p&gt;SUM、AVG、MAX、MIN、COUNT&lt;/p&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;p&gt;​   1、sum、avg一般用于处理数值型&lt;/p&gt;

&lt;p&gt;​         max、min、count可以处理任何类型&lt;/p&gt;

&lt;p&gt;​   2、以上分组函数都忽略null值&lt;/p&gt;

&lt;p&gt;​   3、可以和distinct搭配实现去重的运算&lt;/p&gt;

&lt;p&gt;​   4、count函数的详细介绍&lt;/p&gt;

&lt;p&gt;​         一般使用count(*)用作统计行数&lt;/p&gt;

&lt;p&gt;​   5、和分组函数一同查询的字段要求是group by后的字段&lt;/p&gt;

&lt;h4 id=&#34;1-简单使用&#34;&gt;1）简单使用&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select SUM(salary) FROM employees;
select AVG(salary) FROM employees;
select MIN(salary) FROM employees;
select MAX(salary) FROM employees;
select COUNT(salary) FROM employees;

select SUM(salary) 和,AVG(salary) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数 FROM employees;

select SUM(salary) 和,ROUND(AVG(salary),2) 平均,MAX(salary) 最高,MIN(salary) 最低,COUNT(salary) 个数 FROM employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-参数支持哪些类型&#34;&gt;2）参数支持哪些类型&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select SUM(last_name),AVG(last_name) FROM emloyees;
select SUM(hiredate),AVG(hiredate) FROM emloyees;
上述两种无意义

select MAX(last_name),MIN(last_name) FROM emloyees;
select MAX(hiredate),MIN(hiredate) FROM emloyees;

select COUNT(commission_pct) FROM employees;
select COUNT(last_name) FROM employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-忽略null值&#34;&gt;3）忽略null值&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select SUM(commission_pct),AVG(commission_pct) FROM emloyees;
select COUNT(commission_pct) FROM employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;4-和distinct搭配&#34;&gt;4）和distinct搭配&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select SUM(DISTINCT salary),SUM(salary) FROM employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;5-count函数的详细介绍&#34;&gt;5）COUNT函数的详细介绍&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select COUNT(*) FROM employees;		#经常用于统计行数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;效率：&lt;/p&gt;

&lt;p&gt;MYISAM存储引擎下，COUNT(*)的效率高&lt;/p&gt;

&lt;p&gt;INNODB存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些（原因：如果是字段需要先判断是否为null，不为才加1，因此效率相对较低）&lt;/p&gt;

&lt;h3 id=&#34;六-分组查询&#34;&gt;六、分组查询&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;​       select 分组函数，列（要求出现在group by的后面）&lt;/p&gt;

&lt;p&gt;​       from 表&lt;/p&gt;

&lt;p&gt;​     【where 筛选条件】&lt;/p&gt;

&lt;p&gt;​       group by 分组的列表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;【order by 子句】
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;​       查询列表必须特殊，要求是分组函数和group by后出现的字段&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;​       1、分组查询中的筛选条件分为两类&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;数据源&lt;/th&gt;
&lt;th&gt;位置&lt;/th&gt;
&lt;th&gt;关键字&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;分组前筛选&lt;/td&gt;
&lt;td&gt;原始表&lt;/td&gt;
&lt;td&gt;group by子句的前面&lt;/td&gt;
&lt;td&gt;where&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;分组后筛选&lt;/td&gt;
&lt;td&gt;分组后的结果集&lt;/td&gt;
&lt;td&gt;group by子句的后面&lt;/td&gt;
&lt;td&gt;having&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;​       ①分组函数做条件肯定是放在having子句&lt;/p&gt;

&lt;p&gt;​       ②能用分组前筛选的，优先考虑使用分组前筛选&lt;/p&gt;

&lt;p&gt;​       2、group by子句支持单个字段分组，多个字段分组（多个字段之间用逗号隔开没有顺序要求），表达式或函数（用的较少）&lt;/p&gt;

&lt;p&gt;​       3、也可以添加排序（排序放在整个分组查询最后）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;引入：查询每个部门的平均工资&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;select AVG(salary) FROM employees;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例1-6&#34;&gt;案例1：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个工种的最高工资&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select MAX(salary),job_id
  FROM employees
  GROUP BY job_id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例2-2&#34;&gt;案例2：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个位置上的部门个数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select COUNT(*),location_id
  FROM departments
  GROUP BY location_id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例3-2&#34;&gt;案例3：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询邮箱中包含a字符的，每个部门的平均工资&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select AVG(salary),deparment_id
  FROM employees
  WHERE email LIKE &#39;%a%&#39;
  GROUP BY deparment_id
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例4-1&#34;&gt;案例4：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询有奖金的每个领导手下员工的最高工资&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select MAX(salary),manager_id
  FROM employees
  WHERE commission_pct IS NOT NULL
  GROUP BY manager_id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例5-1&#34;&gt;案例5：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询哪个部门的员工个数&amp;gt;2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①查询每个部门的员工个数&lt;/p&gt;

&lt;p&gt;②根据①的结果进行筛选，查询哪个部门的员工个数&amp;gt;2&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select COUNT(*),department_id
  FROM employees
  GROUP BY department_id
  HAVING COUNT(*)&amp;gt;2;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例6&#34;&gt;案例6：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个工种有奖金的员工的最高工资&amp;gt;12000的工种编号和最高工资&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①查询每个工种有奖金的员工的最高工资&lt;/p&gt;

&lt;p&gt;②根据①结果继续筛选，最高工资&amp;gt;12000&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select job_id,MAX(salary)
  FROM employees
  WHERE commission_pct IS NOT NULL
  GROUP BY job_id
  HAVING MAX(salary)&amp;gt;12000;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例7&#34;&gt;案例7：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询领导编号&amp;gt;102的每个领导手下最低工资&amp;gt;5000的领导编号是哪个，以及其最低工资&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①查询每个领导手下的员工固定最低工资&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select manager_id,MIN(salary)
  FROM employees
  GROUP BY manager_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②添加筛选条件，编号&amp;gt;102&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select manager_id,MIN(salary)
  FROM employees
  WHERE manager_id&amp;gt;102		#manager_id在employees表里，因此放在group by前面
  GROUP BY manager_id
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;③添加筛选条件，最低工资&amp;gt;5000&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select manager_id,MIN(salary)
  FROM employees
  WHERE manager_id&amp;gt;102		#manager_id在employees表里，因此放在group by前面
  GROUP BY manager_id
  HAVING MIN(salary)&amp;gt;5000
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;按表达式或函数分组&#34;&gt;按表达式或函数分组&lt;/h4&gt;

&lt;h5 id=&#34;案例8&#34;&gt;案例8：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&amp;gt;5的有哪些&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;①查询每个长度的员工个数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select COUNT(*),LENGTH(last_name) len_name
  FROM employees
  GROUP BY LENGTH(last_name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;②添加筛选条件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select COUNT(*),LENGTH(last_name) len_name
  FROM employees
  GROUP BY LENGTH(last_name)
  HAVING COUNT(*)&amp;gt;5;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;按多个字段分组&#34;&gt;按多个字段分组&lt;/h4&gt;

&lt;h5 id=&#34;案例9&#34;&gt;案例9：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个部门每个工种的员工的平均工资&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select AVG(salary),department_id,job_id
  FROM employees
  GROUP BY department_id,job_id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;添加排序&#34;&gt;添加排序&lt;/h4&gt;

&lt;h5 id=&#34;案例10&#34;&gt;案例10：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个部门每个工种的员工的平均工资，并且按平均工资的高低显示&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select AVG(salary),department_id,job_id
  FROM employees
  GROUP BY department_id,job_id
  HAVING AVG(salary)&amp;gt;10000
  ORDER BY AVG(salary) DESC;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;七-连接查询&#34;&gt;七、连接查询&lt;/h3&gt;

&lt;p&gt;含义：又称多表查询，当查询的字段来自于多个表时，就会用到连接查询&lt;/p&gt;

&lt;p&gt;笛卡尔乘积现象：表1有m行，表2有n行，结果=m*n行&lt;/p&gt;

&lt;p&gt;发生原因：没有有效的连接条件&lt;/p&gt;

&lt;p&gt;如何避免：添加有效的连接条件&lt;/p&gt;

&lt;p&gt;分类：&lt;/p&gt;

&lt;p&gt;​       内连接：&lt;/p&gt;

&lt;p&gt;​                   等值连接&lt;/p&gt;

&lt;p&gt;​                   非等值连接&lt;/p&gt;

&lt;p&gt;​                   自连接&lt;/p&gt;

&lt;p&gt;​       外连接：&lt;/p&gt;

&lt;p&gt;​                   左外连接&lt;/p&gt;

&lt;p&gt;​                   右外连接&lt;/p&gt;

&lt;p&gt;​                   全外连接&lt;/p&gt;

&lt;p&gt;​       交叉连接&lt;/p&gt;

&lt;h3 id=&#34;1-sql92语法&#34;&gt;1）sql92语法：&lt;/h3&gt;

&lt;h4 id=&#34;1-等值连接&#34;&gt;1、等值连接&lt;/h4&gt;

&lt;h5 id=&#34;案例1-7&#34;&gt;案例1：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询女神名和对应的男神名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select name,boyName 
  From boys,beauty
  where beauty.boyfriend_id=boys.id;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例2-3&#34;&gt;案例2：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名和对应的部门名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select last_name,department_name
  FROM employees,departments
  WHERE employees.&#39;department_id&#39;=departments.&#39;department_id&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例3-3&#34;&gt;案例3：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名、工种号、工种名(起别名)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select last_name,employees.job_id,job_title
  FROM employees,jobs
  where employees.&#39;job_id&#39;=jobs.&#39;job_id&#39;;
  
  select last_name,e.job_id,job_title
  FROM employees as e,jobs as j
  where e.&#39;job_id&#39;=j.&#39;job_id&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例4-2&#34;&gt;案例4：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询有奖金的员工名、部门名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select last_name,department_name,commission_pct
  from employees e,departments d
  where e.&#39;department_id&#39;=d.&#39;department_id&#39;
  and e.&#39;commission_pct&#39; is not null;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例5-2&#34;&gt;案例5：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询城市名中第二个字符为o的部门名和城市名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select department_name,city
  from departments d,locations l
  where d.&#39;location_id&#39;=l.&#39;location_id&#39;
  and city like &#39;_o%&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例6-1&#34;&gt;案例6：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个城市的部门个数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select count(*) 个数,city
  from departments d,locations l
  where d.&#39;location_id&#39;=l.&#39;location_id&#39;
  group by city;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例7-1&#34;&gt;案例7：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询有奖金的每个部门的部门名称和部门的领导编号和该部门的最低工资&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select department_name,d.&#39;manager_id&#39;,min(salary)
  from departments d,employees e
  where d.&#39;department_id&#39;=e.&#39;department_id&#39;
  and commission_pct is not null
  group by department_name;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例8-1&#34;&gt;案例8：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个工种的工种名和员工的个数，并且按员工个数降序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select job_title,count(*)
  from employees e,jobs j
  where e.&#39;job_id&#39;=j.&#39;job_id&#39;
  group by job_title
  group by count(*) desc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例9-1&#34;&gt;案例9：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名、部门名和所在城市&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select last_name,department_name,city
  from employees e,departments d,locations l
  where e.&#39;department_id&#39;=d.&#39;department_id&#39;
  and d.&#39;location_id&#39;=l.&#39;location_id&#39;
  and city like &#39;s%&#39;
  order by department_name desc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-非等值连接&#34;&gt;2、非等值连接&lt;/h4&gt;

&lt;h5 id=&#34;案例1-8&#34;&gt;案例1：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工的工资和工资级别&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select salary,grade_level
  from employees e,job_grades g
  where salary between g.&#39;lowest_sal&#39; and g.&#39;highest_sal&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;3-自连接&#34;&gt;3、自连接&lt;/h4&gt;

&lt;h5 id=&#34;案例1-9&#34;&gt;案例1：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名和上级的名称&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select e.&#39;last_name&#39;,e.&#39;employee_id&#39;,m.&#39;last_name&#39;,m.&#39;employee_id&#39;,
  from employees e,employees m
  where e.&#39;manager_id&#39;=m.&#39;employee_id&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;2-sql99语法&#34;&gt;2）sql99语法：&lt;/h3&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;p&gt;​       select 查询列表&lt;/p&gt;

&lt;p&gt;​       from 表1 别名 【连接类型】&lt;/p&gt;

&lt;p&gt;​       join   表2 别名&lt;/p&gt;

&lt;p&gt;​       on     连接条件&lt;/p&gt;

&lt;p&gt;​       【where 筛选条件】&lt;/p&gt;

&lt;p&gt;​       【group by 分组】&lt;/p&gt;

&lt;p&gt;​       【having 筛选条件】&lt;/p&gt;

&lt;p&gt;​       【order by 排序列表】&lt;/p&gt;

&lt;p&gt;分类：&lt;/p&gt;

&lt;p&gt;内连接（*）：inner&lt;/p&gt;

&lt;p&gt;外连接：&lt;/p&gt;

&lt;p&gt;​           左外（*）：left 【outer】&lt;/p&gt;

&lt;p&gt;​           右外（*）：right 【outer】&lt;/p&gt;

&lt;p&gt;​           全外：full 【outer】&lt;/p&gt;

&lt;p&gt;交叉连接：cross&lt;/p&gt;

&lt;h4 id=&#34;1-内连接&#34;&gt;1、内连接&lt;/h4&gt;

&lt;p&gt;语法：&lt;/p&gt;

&lt;p&gt;select 查询列表&lt;/p&gt;

&lt;p&gt;from 表1 别名&lt;/p&gt;

&lt;p&gt;inner join 表2 别名&lt;/p&gt;

&lt;p&gt;on 连接条件&lt;/p&gt;

&lt;h4 id=&#34;①等值连接&#34;&gt;①等值连接&lt;/h4&gt;

&lt;h5 id=&#34;案例1-10&#34;&gt;案例1：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名、部门名&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select last_name,department_name
  from employees e
  inner join departments d
  on e.&#39;department_id&#39;=d.&#39;department_id&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例2-4&#34;&gt;案例2：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询名字中包含e的员工名和工种名（筛选）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select last_name,job_title
  from employees e
  inner join jobs j
  on e.&#39;job_id&#39;=j.&#39;job_id&#39;
  where e.&#39;last_name&#39; like &#39;%e%&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例3-4&#34;&gt;案例3：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询部门个数&amp;gt;3的城市名和部门个数（添加分组+筛选）&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select city,count(*) 部门个数
  from departments d
  inner join location l
  on d.&#39;location_id&#39;=l.&#39;location_id&#39;
  group by city
  having count(*)&amp;gt;3;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例4-3&#34;&gt;案例4：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询哪个部门的部门员工个数&amp;gt;3的部门名和员工个数，并按个数降序(添加排序)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select department_name,count(*) 个数
  from employees e
  inner join departments d
  on e.&#39;department_id&#39;=d.&#39;department_id&#39;
  group by d.&#39;department_name&#39;
  having count(*)&amp;gt;3
  order by count(*) desc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例5-3&#34;&gt;案例5：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工名、部门名、工种名，并按部门名降序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select last_name,department_name,job_title
  from employees e
  inner join departments d 
  on e.&#39;department_id&#39;=d.&#39;deparmtent_id&#39;
  inner join jobs j
  on e.&#39;job_id&#39;=j.&#39;job_id&#39;
  order by department_name desc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;②非等值连接&#34;&gt;②非等值连接&lt;/h4&gt;

&lt;h5 id=&#34;案例1-11&#34;&gt;案例1：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工的工资级别&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select salary,grade_level
  from employees e
  join job_grades g
  on e.&#39;salary&#39; between g.&#39;lowest_sal&#39; and g.&#39;highest_sal&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;案例2-5&#34;&gt;案例2：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询每个工资级别的个数&amp;gt;2的个数，并且按工资级别降序&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select count(*),grade_level
  from employees e
  join job_grades g
  on e.&#39;salary&#39; between g.&#39;lowest_sal&#39; and g.&#39;highest_sal&#39;
  group by grade_level
  having count(*)&amp;gt;2
  order by grade_level desc;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;③自连接&#34;&gt;③自连接&lt;/h4&gt;

&lt;h5 id=&#34;案例1-12&#34;&gt;案例1：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询员工的名字、上级的名字&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select e.&#39;last_name&#39;,m.&#39;last_name&#39;
  from employees e
  join employees m
  on e.&#39;manager_id&#39;=m.&#39;employee_id&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;2-外连接&#34;&gt;2、外连接&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;应用场景&lt;/strong&gt;：用于查询一个表中有，另一个表没有的记录&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;1、外连接的插叙结果为主表中的所有记录&lt;/p&gt;

&lt;p&gt;​       如果从表中有和它匹配的，则显示匹配的值&lt;/p&gt;

&lt;p&gt;​       如果从表中没有和它匹配的，则显示null&lt;/p&gt;

&lt;p&gt;​       外连接查询结果=内连接结果+主表中有而从表没有的记录&lt;/p&gt;

&lt;p&gt;2、左外连接，left左边的是主表&lt;/p&gt;

&lt;p&gt;​     右外连接，right  join右边的是主表&lt;/p&gt;

&lt;p&gt;3、左外和右外交换两个表的顺序，可以实现同样的效果&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;select 查询列表&lt;/p&gt;

&lt;p&gt;from 表1 别名&lt;/p&gt;

&lt;p&gt;left(right) join 表2 别名&lt;/p&gt;

&lt;p&gt;on 连接条件&lt;/p&gt;

&lt;h4 id=&#34;①左外-右外连接&#34;&gt;①左外、右外连接&lt;/h4&gt;

&lt;h5 id=&#34;案例1-13&#34;&gt;案例1：&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;查询哪个部门没有员工&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;  select d.*,employee_id
  from departments d
  left join employees e
  on d.&#39;department_id&#39;=e.&#39;department_id&#39;
  where e.&#39;employee_id&#39; is null;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;②全外连接&#34;&gt;②全外连接&lt;/h4&gt;

&lt;h5 id=&#34;案例1-14&#34;&gt;案例1：&lt;/h5&gt;
</description>
      
    </item>
    
    <item>
      <title>Golang的Channel底层原理</title>
      <link>https://linchengLC.github.io/post/golang%E7%9A%84channel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</link>
      <pubDate>Tue, 12 Nov 2019 15:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/golang%E7%9A%84channel%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</guid>
      
        <description>

&lt;h2 id=&#34;channel的整体结构图&#34;&gt;channel的整体结构图&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1b52ab08?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;简单说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;是有缓冲的channel所特有的结构，用来存储缓存数据。是个循环链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sendx&lt;/code&gt;和&lt;code&gt;recvx&lt;/code&gt;用于记录&lt;code&gt;buf&lt;/code&gt;这个循环链表中的~发送或者接收的~index&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lock&lt;/code&gt;是个互斥锁。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;recvq&lt;/code&gt;和&lt;code&gt;sendq&lt;/code&gt;分别是接收(&amp;lt;-channel)或者发送(channel &amp;lt;- xxx)的goroutine抽象出来的结构体(sudog)的队列。是个双向链表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;源码位于&lt;code&gt;/runtime/chan.go&lt;/code&gt;中(目前版本：1.11)。结构体为&lt;code&gt;hchan&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type hchan struct {
    qcount   uint           // total data in the queue
    dataqsiz uint           // size of the circular queue
    buf      unsafe.Pointer // points to an array of dataqsiz elements
    elemsize uint16
    closed   uint32
    elemtype *_type // element type
    sendx    uint   // send index
    recvx    uint   // receive index
    recvq    waitq  // list of recv waiters
    sendq    waitq  // list of send waiters

    // lock protects all fields in hchan, as well as several
    // fields in sudogs blocked on this channel.
    //
    // Do not change another G&#39;s status while holding this lock
    // (in particular, do not ready a G), as this can deadlock
    // with stack shrinking.
    lock mutex
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面我们来详细介绍&lt;code&gt;hchan&lt;/code&gt;中各部分是如何使用的。&lt;/p&gt;

&lt;h2 id=&#34;先从创建开始&#34;&gt;先从创建开始&lt;/h2&gt;

&lt;p&gt;我们首先创建一个channel。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch:=make(chan int,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1b6f96fc?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;创建channel实际上就是在内存中实例化了一个&lt;code&gt;hchan&lt;/code&gt;的结构体，并返回一个ch指针，我们使用过程中channel在函数之间的传递都是用的这个指针，这就是为什么函数传递中无需使用channel的指针，而直接使用channel就行了，因为channel本身就是一个指针。&lt;/p&gt;

&lt;h2 id=&#34;channel中发送send-ch-xxx-和recv-ch-接收&#34;&gt;channel中发送send(ch &amp;lt;- xxx)和recv(&amp;lt;- ch)接收&lt;/h2&gt;

&lt;p&gt;先考虑一个问题，如果你想让goroutine以先进先出(FIFO)的方式进入一个结构体中，你会怎么操作？ 加锁！对的！channel就是用了一个锁。hchan本身包含一个互斥锁&lt;code&gt;mutex&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;channel中队列是如何实现的&#34;&gt;channel中队列是如何实现的&lt;/h3&gt;

&lt;p&gt;channel中有个缓存buf，是用来缓存数据的(假如实例化了带缓存的channel的话)队列。我们先来看看是如何实现“队列”的。 还是刚才创建的那个channel&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch:=make(chan int,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1cde7276?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;当使用&lt;code&gt;send (ch &amp;lt;- xx)&lt;/code&gt;或者&lt;code&gt;recv ( &amp;lt;-ch)&lt;/code&gt;的时候，首先要锁住&lt;code&gt;hchan&lt;/code&gt;这个结构体。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1d501497?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后开始&lt;code&gt;send (ch &amp;lt;- xx)&lt;/code&gt;数据。&lt;/p&gt;

&lt;p&gt;一&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch&amp;lt;-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch&amp;lt;-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;ch&amp;lt;-1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时候满了，队列塞不进去了，动态图表示为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1d1b2a18?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;然后是取&lt;code&gt;recv ( &amp;lt;-ch)&lt;/code&gt;的过程，是个逆向的操作，也是需要加锁。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42b1d6c9e89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;然后开始&lt;code&gt;recv(&amp;lt;-ch)&lt;/code&gt;数据。&lt;/p&gt;

&lt;p&gt;一&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c0265625b?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;注意以上两幅图中&lt;code&gt;buf&lt;/code&gt;和&lt;code&gt;recvx&lt;/code&gt;以及&lt;code&gt;sendx&lt;/code&gt;的变化，&lt;code&gt;recvx&lt;/code&gt;和&lt;code&gt;sendx&lt;/code&gt;是根据循环链表&lt;code&gt;buf&lt;/code&gt;的变动而改变的。 至于为什么channel会使用循环链表作为缓存结构，我个人认为是在缓存列表在动态的&lt;code&gt;send&lt;/code&gt;和&lt;code&gt;recv&lt;/code&gt;过程中，定位当前&lt;code&gt;send&lt;/code&gt;或者&lt;code&gt;recvx&lt;/code&gt;的位置、选择&lt;code&gt;send&lt;/code&gt;的和&lt;code&gt;recvx&lt;/code&gt;的位置比较方便吧，只要顺着链表顺序一直旋转操作就好。&lt;/p&gt;

&lt;p&gt;缓存中按链表顺序存放，取数据的时候按链表顺序读取，符合FIFO的原则。&lt;/p&gt;

&lt;h3 id=&#34;send-recv的细化操作&#34;&gt;send/recv的细化操作&lt;/h3&gt;

&lt;p&gt;注意：缓存链表中以上每一步的操作，都是需要加锁操作的！&lt;/p&gt;

&lt;p&gt;每一步的操作的细节可以细化为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;第一，加锁&lt;/li&gt;
&lt;li&gt;第二，把数据从goroutine中copy到”队列“中（或者从队列中copy到goroutine中）&lt;/li&gt;
&lt;li&gt;第三，释放锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;每一步的操作总结为动态图为：（发送过程）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c18219683?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;或者为：（接收过程）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c1e49b4ab?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;所以不难看出，Go中那句经典的话：&lt;code&gt;Do not communicate by sharing memory; instead, share memory by communicating.&lt;/code&gt;的具体实现就是利用channel把数据从一端copy到了另一端！ 还真是符合&lt;code&gt;channel&lt;/code&gt;的英文含义：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c4eff6a3f?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;当channel缓存满了之后会发生什么-这其中的原理是怎样的&#34;&gt;当channel缓存满了之后会发生什么？这其中的原理是怎样的？&lt;/h3&gt;

&lt;p&gt;使用的时候，我们都知道，当channel缓存满了，或者没有缓存的时候，我们继续send(ch &amp;lt;- xxx)或者recv(&amp;lt;- ch)会阻塞当前goroutine，但是，是如何实现的呢？&lt;/p&gt;

&lt;p&gt;我们知道，Go的goroutine是用户态的线程(&lt;code&gt;user-space threads&lt;/code&gt;)，用户态的线程是需要自己去调度的，Go有运行时的scheduler去帮我们完成调度这件事情。关于Go的调度模型GMP模型我在此不做赘述，如果不了解，可以看我另一篇文章(&lt;a href=&#34;https://i6448038.github.io/2017/12/04/golang-concurrency-principle/&#34;&gt;Go调度原理&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;goroutine的阻塞操作，实际上是调用&lt;code&gt;send (ch &amp;lt;- xx)&lt;/code&gt;或者&lt;code&gt;recv ( &amp;lt;-ch)&lt;/code&gt;的时候主动触发的，具体请看以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;//goroutine1 中，记做G1

ch := make(chan int, 3)

ch &amp;lt;- 1
ch &amp;lt;- 1
ch &amp;lt;- 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c655f26fa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c7e0fa6b0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候G1正在正常运行,当再次进行send操作(ch&amp;lt;-1)的时候，会主动调用Go的调度器,让G1等待，并从让出M，让其他G去使用&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42cdb898891?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;同时G1也会被抽象成含有G1指针和send元素的&lt;code&gt;sudog&lt;/code&gt;结构体保存到hchan的&lt;code&gt;sendq&lt;/code&gt;中等待被唤醒。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42c806cd876?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那么，G1什么时候被唤醒呢？这个时候G2隆重登场。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42cf9b7a64b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;G2执行了recv操作&lt;code&gt;p := &amp;lt;-ch&lt;/code&gt;，于是会发生以下的操作：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d08bb757a?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;G2从缓存队列中取出数据，channel会将等待队列中的G1推出，将G1当时send的数据推到缓存中，然后调用Go的scheduler，唤醒G1，并把G1放到可运行的Goroutine队列中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d0cad71b9?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;假如是先进行执行recv操作的g2会怎么样&#34;&gt;假如是先进行执行recv操作的G2会怎么样？&lt;/h3&gt;

&lt;p&gt;你可能会顺着以上的思路反推。首先：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d3ba03093?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个时候G2会主动调用Go的调度器,让G2等待，并从让出M，让其他G去使用。 G2还会被抽象成含有G2指针和recv空元素的&lt;code&gt;sudog&lt;/code&gt;结构体保存到hchan的&lt;code&gt;recvq&lt;/code&gt;中等待被唤醒&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42d58ad1148?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;此时恰好有个goroutine G1开始向channel中推送数据 &lt;code&gt;ch &amp;lt;- 1&lt;/code&gt;。 此时，非常有意思的事情发生了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42ddfc04314?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;p&gt;G1并没有锁住channel，然后将数据放到缓存中，而是直接把数据从G1直接copy到了G2的栈中。 这种方式非常的赞！在唤醒过程中，G2无需再获得channel的锁，然后从缓存中取数据。减少了内存的copy，提高了效率。&lt;/p&gt;

&lt;p&gt;之后的事情显而易见：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-gold-cdn.xitu.io/2019/4/14/16a1c42e5df40117?imageslim&#34; alt=&#34;img&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;文章来源：&lt;a href=&#34;https://juejin.im/post/5cb3445f6fb9a068b748ab75&#34;&gt;https://juejin.im/post/5cb3445f6fb9a068b748ab75&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>为什么使用sync.pool</title>
      <link>https://linchengLC.github.io/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8sync.pool/</link>
      <pubDate>Sat, 26 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8sync.pool/</guid>
      
        <description>

&lt;h4 id=&#34;介绍&#34;&gt;介绍&lt;/h4&gt;

&lt;p&gt;因为使用Pool后更快。通过文章底部存储库中的基准测试可以较少4982被的内存占用&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://upload-images.jianshu.io/upload_images/19131697-1865b3c2c293422e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;相比之下，Pool的性能更快更好&lt;/p&gt;

&lt;h4 id=&#34;ok-这究竟是怎么回事呢&#34;&gt;ok，这究竟是怎么回事呢？&lt;/h4&gt;

&lt;p&gt;垃圾回收定期执行。如果你的代码不断地在进行一些数据结构中分配内存然后释放他们，这就会导致收集器的不断工作，使得更多的内存和CPU被用来在初始化结构体时分配资源。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对sync/pool.go的描述如下：&lt;/p&gt;

&lt;p&gt;Pool是一组可以单独保存和检索的临时对象。&lt;/p&gt;

&lt;p&gt;Pool可以安全地同时使用多个Goroutine。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;sync.Pool&lt;/strong&gt;允许我们重用内存而非重新分配。&lt;/p&gt;

&lt;p&gt;此外，如果你使用的 http 服务器接收带有 JSON 请求体的 post 请求，并且它必须被解码到结构体中，你可以使用 &lt;strong&gt;sync.Pool&lt;/strong&gt; 来节省内存并减少服务器响应时间。&lt;/p&gt;

&lt;h2 id=&#34;sync-pool-用法&#34;&gt;sync.Pool 用法&lt;/h2&gt;

&lt;p&gt;sync.Pool 构造很简单：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var bufferPool = sync.Pool{	
	New: func() interface{} {		
			return new(bytes.Buffer)	
	},
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在你将会创建一个 Pool 和新的缓冲区。你可以这样创建第一个缓冲区：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buffer := bufferPool.Get().(*bytes.Buffer)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;get 方法会返回 Pool 中已存在的 *&lt;strong&gt;bytes.Buffer&lt;/strong&gt;，否则将调用 &lt;strong&gt;New&lt;/strong&gt; 方法来初始化新的 *&lt;strong&gt;bytes.Buffer&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;但在缓冲区使用后，你必须将其重置并放回 Pool 中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;buffer.Reset()bufferPool.Put(buffer)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;基准测试&#34;&gt;基准测试&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;参数解释：&lt;/p&gt;

&lt;p&gt;数字&lt;code&gt;8&lt;/code&gt;表示&lt;code&gt;GOMAXPROCS&lt;/code&gt;的值，这个对于并发基准测试很重要。&lt;code&gt;5000000&lt;/code&gt;和&lt;code&gt;384ns/op&lt;/code&gt;表示每次调用&lt;code&gt;bytes.Buffer&lt;/code&gt;函数耗时&lt;code&gt;384ns&lt;/code&gt;，这个结果是&lt;code&gt;5000000&lt;/code&gt;次调用的平均值，&lt;code&gt;0 B/op&lt;/code&gt;表示每次操作内存分配了0字节，&lt;code&gt;0 allocs/op&lt;/code&gt;则表示每次操作进行了0次内存分配。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;将-json-编码为-bytes-buffer&#34;&gt;将 JSON 编码为 bytes.Buffer&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// 对 JSON 编码的代码段
BenchmarkReadStreamWithPool-8        5000000        384 ns/op   0 B/op   0allocs/op
BenchmarkReadStreamWithoutPool-8     3000000        554 ns/op   160 B/op 2 allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们得到了 44% 的性能提升并且节省了非常多的内存 (160B/ops vs 0B/ops)。&lt;/p&gt;

&lt;h3 id=&#34;将字节写入-bufio-writer&#34;&gt;将字节写入 bufio.Writer&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;BenchmarkWriteBufioWithPool-8       10000000        123 ns/op      128 B/op 2allocs/op
BenchmarkWriteBufioWithoutPool-8     2000000        651 ns/op     4288 B/op 4allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们得到了 5 倍性能提升并且减少了 32 倍内存使用。&lt;/p&gt;

&lt;h3 id=&#34;将-json-解码为-struct&#34;&gt;将 JSON 解码为 struct&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;BenchmarkJsonDecodeWithPool-8        1000000       1729 ns/op     1128 B/op 8allocs/op
BenchmarkJsonDecodeWithoutPool-8     1000000       1751 ns/op     1160 B/op 9allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为 JSON 解码操作太难，我们的性能只提升了 1%，我们无法通过重用结构体得到正常的提升。&lt;/p&gt;

&lt;h3 id=&#34;gzip-字节&#34;&gt;Gzip 字节&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;BenchmarkWriteGzipWithPool-8          500000    2339 ns/op      162 B/op 2allocs/op
BenchmarkWriteGzipWithoutPool-8       10000     105288 ns/op   807088 B/op 16allocs/op
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;等等，什么？性能提升了 45 倍并且内存使用量减少了 4982 倍。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;务必使用 &lt;strong&gt;sync.Pool&lt;/strong&gt; ！它确实可以节省内存并提高应用程序的性能。&lt;/p&gt;

&lt;p&gt;基准测试的 Github 存储库在&lt;a href=&#34;https://github.com/Mnwa/GoBench&#34;&gt;&lt;strong&gt;这里&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;摘自Go语言中文网&lt;a href=&#34;https://studygolang.com/articles/21384&#34;&gt;https://studygolang.com/articles/21384&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
      
    </item>
    
    <item>
      <title>面试知识点</title>
      <link>https://linchengLC.github.io/post/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</link>
      <pubDate>Sat, 26 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</guid>
      
        <description>

&lt;h1 id=&#34;1-前言&#34;&gt;1. 前言&lt;/h1&gt;

&lt;p&gt;面试考察的知识点多而杂，要完全掌握需要花费大量的时间和精力。但是面试中经常被问到的知识点却没有多少，你完全可以用 20% 的时间去掌握 80% 常问的知识点。在这里我将这 80% 常问的知识点整理出来，方便大家快速地掌握。这些知识点也标注了重要程度，从而让大家可以根据知识点的重要程度去制定学习计划。&lt;/p&gt;

&lt;p&gt;如果你想更好的学习这些知识点，可以参考 &lt;a href=&#34;https://xiaozhuanlan.com/topic/4150387926&#34;&gt;知识总结方法&lt;/a&gt; 一文，这篇文章的最后给出了比本文更详细的思维导图。&lt;/p&gt;

&lt;p&gt;下图列出了面试考察的九大知识点，也标出了重要程度和复习难度。&lt;/p&gt;

&lt;p&gt;其实重要程度根据不同的公司会有所不同，针对上图做一下几点说明：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;分布式与系统设计部分对于大厂面试来说至关重要，但是小厂面试考察的会少一点。&lt;/li&gt;
&lt;li&gt;语言基础部分，阿里喜欢问 Java、腾讯喜欢问 C++，其它大厂面试考察会少一些，小厂面试会考察多一些。&lt;/li&gt;
&lt;li&gt;数据库、中间件和框架部分对于大厂面试来说不是那么重要，但是对于小厂面试会重要一些。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后再说一下项目部分，它在实习招聘阶段中不是特别重要，但是在校园招聘阶段重要程度会增高。但是如果你的学历不好，而且没有博客、开源项目、竞赛等加分项，那么最好做个比较出色的项目来增加简历通过率。&lt;/p&gt;

&lt;p&gt;💻&lt;/p&gt;

&lt;h1 id=&#34;2-操作系统&#34;&gt;2. 操作系统&lt;/h1&gt;

&lt;h2 id=&#34;2-1-基础&#34;&gt;2.1 基础&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ 进程与线程的本质区别、以及各自的使用场景。&lt;/li&gt;
&lt;li&gt;★☆☆ 进程状态。&lt;/li&gt;
&lt;li&gt;★★★ 进程调度算法的特点以及使用场景。&lt;/li&gt;
&lt;li&gt;★☆☆ 线程实现的方式。&lt;/li&gt;
&lt;li&gt;★★☆ 协程的作用。&lt;/li&gt;
&lt;li&gt;★★☆ 常见进程同步问题。&lt;/li&gt;
&lt;li&gt;★★★ 进程通信方法的特点以及使用场景。&lt;/li&gt;
&lt;li&gt;★★★ 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁。&lt;/li&gt;
&lt;li&gt;★★★ 虚拟内存的作用，分页系统实现虚拟内存原理。&lt;/li&gt;
&lt;li&gt;★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。&lt;/li&gt;
&lt;li&gt;★★★ 比较分页与分段的区别。&lt;/li&gt;
&lt;li&gt;★★★ 分析静态链接的不足，以及动态链接的特点。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2-2-linux&#34;&gt;2.2 Linux&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 文件系统的原理，特别是 inode 和 block。数据恢复原理。&lt;/li&gt;
&lt;li&gt;★★★ 硬链接与软链接的区别。&lt;/li&gt;
&lt;li&gt;★★☆ 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。&lt;/li&gt;
&lt;li&gt;★★★ 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;☁️&lt;/p&gt;

&lt;h1 id=&#34;3-网络&#34;&gt;3. 网络&lt;/h1&gt;

&lt;h2 id=&#34;3-1-基础&#34;&gt;3.1 基础&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ 各层协议的作用，以及 TCP/IP 协议的特点。&lt;/li&gt;
&lt;li&gt;★★☆ 以太网的特点，以及帧结构。&lt;/li&gt;
&lt;li&gt;★★☆ 集线器、交换机、路由器的作用，以及所属的网络层。&lt;/li&gt;
&lt;li&gt;★★☆ IP 数据数据报常见字段的作用。&lt;/li&gt;
&lt;li&gt;★☆☆ ARP 协议的作用，以及维护 ARP 缓存的过程。&lt;/li&gt;
&lt;li&gt;★★☆ ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。&lt;/li&gt;
&lt;li&gt;★★★ UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。&lt;/li&gt;
&lt;li&gt;★★★ 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。&lt;/li&gt;
&lt;li&gt;★★★ 可靠传输原理，并设计可靠 UDP 协议。&lt;/li&gt;
&lt;li&gt;★★☆ TCP 拥塞控制的作用，理解具体原理。&lt;/li&gt;
&lt;li&gt;★★☆ DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-2-http&#34;&gt;3.2 HTTP&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。&lt;/li&gt;
&lt;li&gt;★★☆ HTTP 状态码。&lt;/li&gt;
&lt;li&gt;★★★ Cookie 作用、安全性问题、和 Session 的比较。&lt;/li&gt;
&lt;li&gt;★★☆ 缓存 的Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。&lt;/li&gt;
&lt;li&gt;★★★ 长连接与短连接原理以及使用场景，流水线。&lt;/li&gt;
&lt;li&gt;★★★ HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。&lt;/li&gt;
&lt;li&gt;★★☆ HTTP/1.x 的缺陷，以及 HTTP/2 的特点。&lt;/li&gt;
&lt;li&gt;★★★ HTTP/1.1 的特性。&lt;/li&gt;
&lt;li&gt;★★☆ HTTP 与 FTP 的比较。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-3-socket&#34;&gt;3.3 Socket&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 五种 IO 模型的特点以及比较。&lt;/li&gt;
&lt;li&gt;★★★ select、poll、epoll 的原理、比较、以及使用场景；epoll 的水平触发与边缘触发。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;💾&lt;/p&gt;

&lt;h1 id=&#34;4-数据库&#34;&gt;4. 数据库&lt;/h1&gt;

&lt;h2 id=&#34;4-1-sql&#34;&gt;4.1 SQL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 手写 SQL 语句，特别是连接查询与分组查询。&lt;/li&gt;
&lt;li&gt;★★☆ 连接查询与子查询的比较。&lt;/li&gt;
&lt;li&gt;★★☆ drop、delete、truncate 比较。&lt;/li&gt;
&lt;li&gt;★★☆ 视图的作用，以及何时能更新视图。&lt;/li&gt;
&lt;li&gt;★☆☆ 理解存储过程、触发器等作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-2-系统原理&#34;&gt;4.2 系统原理&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ ACID 的作用以及实现原理。&lt;/li&gt;
&lt;li&gt;★★★ 四大隔离级别，以及不可重复读和幻影读的出现原因。&lt;/li&gt;
&lt;li&gt;★★☆ 封锁的类型以及粒度，两段锁协议，隐式和显示锁定。&lt;/li&gt;
&lt;li&gt;★★★ 乐观锁与悲观锁。&lt;/li&gt;
&lt;li&gt;★★★ MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读。&lt;/li&gt;
&lt;li&gt;★★☆ 范式理论。&lt;/li&gt;
&lt;li&gt;★★★ SQL 与 NoSQL 的比较。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-3-mysql&#34;&gt;4.3 MySQL&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ B+ Tree 原理，与其它查找树的比较。&lt;/li&gt;
&lt;li&gt;★★★ MySQL 索引以及优化。&lt;/li&gt;
&lt;li&gt;★★★ 查询优化。&lt;/li&gt;
&lt;li&gt;★★★ InnoDB 与 MyISAM 比较。&lt;/li&gt;
&lt;li&gt;★★☆ 水平切分与垂直切分。&lt;/li&gt;
&lt;li&gt;★★☆ 主从复制原理、作用、实现。&lt;/li&gt;
&lt;li&gt;★☆☆ redo、undo、binlog 日志的作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;4-4-redis&#34;&gt;4.4 Redis&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 字典和跳跃表原理分析。&lt;/li&gt;
&lt;li&gt;★★★ 使用场景。&lt;/li&gt;
&lt;li&gt;★★★ 与 Memchached 的比较。&lt;/li&gt;
&lt;li&gt;★☆☆ 数据淘汰机制。&lt;/li&gt;
&lt;li&gt;★★☆ RDB 和 AOF 持久化机制。&lt;/li&gt;
&lt;li&gt;★★☆ 事件驱动模型。&lt;/li&gt;
&lt;li&gt;★☆☆ 主从复制原理。&lt;/li&gt;
&lt;li&gt;★★★ 集群与分布式。&lt;/li&gt;
&lt;li&gt;★★☆ 事务原理。&lt;/li&gt;
&lt;li&gt;★★★ 线程安全问题。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;🎨&lt;/p&gt;

&lt;h1 id=&#34;5-面向对象&#34;&gt;5. 面向对象&lt;/h1&gt;

&lt;h2 id=&#34;5-1-思想&#34;&gt;5.1 思想&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★★ 面向对象三大特性&lt;/li&gt;
&lt;li&gt;★☆☆ 设计原则&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;5-2-设计模式&#34;&gt;5.2 设计模式&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;★★☆ 设计模式的作用。&lt;/li&gt;
&lt;li&gt;★★★ 手写单例模式，特别是双重检验锁以及静态内部类。&lt;/li&gt;
&lt;li&gt;★★★ 手写工厂模式。&lt;/li&gt;
&lt;li&gt;★★★ 理解 MVC，结合 SpringMVC 回答。&lt;/li&gt;
&lt;li&gt;★★★ 理解代理模式，结合 Spring 中的 AOP 回答。&lt;/li&gt;
&lt;li&gt;★★★ 分析 JDK 中常用的设计模式，例如装饰者模式、适配器模式、迭代器模式等。&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>反转整数</title>
      <link>https://linchengLC.github.io/post/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</link>
      <pubDate>Fri, 18 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0/</guid>
      
        <description>&lt;p&gt;给定一个 32 位有符号整数，将整数中的数字进行反转。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 123&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 321&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; -123&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; -321&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; 120&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 21&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31 ,  2^31 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现思路:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1.如果x为负数则将标志位sign置为-1，并且将x变为正数&lt;/p&gt;

&lt;p&gt;2.for循环&lt;/p&gt;

&lt;p&gt;对x取10余得到temp&lt;/p&gt;

&lt;p&gt;放入res头内res*10+temp&lt;/p&gt;

&lt;p&gt;将x去除末尾&lt;/p&gt;

&lt;p&gt;3.还原x的符号到res&lt;/p&gt;

&lt;p&gt;4.处理res的溢出问题，使用math.maxint32和math.minint32&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;代码实现:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Reverse Integer
 * 反转整数
*/
import (
	“math”
)
func reverse(x int) int {
	sign := 1
	// 处理负数
	if x &amp;lt; 0 {
		sign = -1
		x = -1 * x
	}
	res := 0
	for x &amp;gt; 0 {
		// 取出x的末尾
		temp := x % 10
		// 放入 res 的开头
		res = res*10 + temp
		// x 去除末尾
		x = x / 10
	}
	// 还原 x 的符号到 res
	res = sign * res
	// 处理 res 的溢出问题
	if res &amp;gt; math.MaxInt32 || res &amp;lt; math.MinInt32 {
		res = 0
	}
	return res
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>罗马数字转换为整数</title>
      <link>https://linchengLC.github.io/post/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0/</link>
      <pubDate>Fri, 18 Oct 2019 12:11:17 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/post/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B4%E6%95%B0/</guid>
      
        <description>&lt;p&gt;罗马数字包含以下七种字符： I ， V ， X ， L ， C ， D 和 M 。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;字符&lt;/strong&gt;  &lt;strong&gt;数值&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I 1&lt;/p&gt;

&lt;p&gt;V 5&lt;/p&gt;

&lt;p&gt;X 10&lt;/p&gt;

&lt;p&gt;L 50&lt;/p&gt;

&lt;p&gt;C 100&lt;/p&gt;

&lt;p&gt;D 500&lt;/p&gt;

&lt;p&gt;M 1000&lt;/p&gt;

&lt;p&gt;例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII , 即为 XX + V + II 。&lt;/p&gt;

&lt;p&gt;通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII ，而是 IV 。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX 。这个特殊的规则只适用于以下六种情况：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。&lt;/li&gt;
&lt;li&gt;X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。&lt;/li&gt;
&lt;li&gt;C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;III&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 3&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;IV&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 4&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;IX&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 9&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 4:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;LVIII&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 58&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解释:&lt;/strong&gt; C = 100, L = 50, XXX = 30, III = 3.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;示例 5:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输入:&lt;/strong&gt; &amp;ldquo;MCMXCIV&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;输出:&lt;/strong&gt; 1994&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解释:&lt;/strong&gt; M = 1000, CM = 900, XC = 90, IV = 4.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现思路:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;1.定义一个map用于存储每个罗马数字代表的整数&lt;/p&gt;

&lt;p&gt;2.定义一个sign标志用于判断前一个罗马数字是否小于后一个罗马数字，如果小于则将sign标志置为-1&lt;/p&gt;

&lt;p&gt;3.从后往前循环遍历字符串，如果前一个罗马数字通过map获取到的值(temp)小于后一个(last)，sign=-1&lt;/p&gt;

&lt;p&gt;​    res=sign*temp&lt;/p&gt;

&lt;p&gt;​    last=temp&lt;/p&gt;

&lt;p&gt;4.返回res&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;代码实现:&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/**
 * Roman to Integer
 * 罗马数字转整数
*/
func romanToInt(s string) int {
	res := 0
	m := map[byte]int{
		‘I’: 1,
		‘V’: 5,
		‘X’: 10,
		‘L’: 50,
		‘C’: 100,
		‘D’: 500,
		‘M’: 1000,
	}
	last := 0
	for i := len(s) - 1; i &amp;gt;= 0; i— {
		temp := m[s[i]]
		sign := 1
		if temp &amp;lt; last {
			//小数在大数的左边，要减去小数
			sign = -1
		}
		res += sign * temp
		last = temp
	}
    return res
}
&lt;/code&gt;&lt;/pre&gt;
</description>
      
    </item>
    
    <item>
      <title>About</title>
      <link>https://linchengLC.github.io/about/</link>
      <pubDate>Sun, 20 Aug 2017 21:38:52 +0800</pubDate>
      
      <guid>https://linchengLC.github.io/about/</guid>
      
        <description>&lt;p&gt;Hugo is a static site engine written in Go.&lt;/p&gt;

&lt;p&gt;It makes use of a variety of open source projects including:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;Cobra&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/jWalterWeatherman&#34;&gt;J Walter Weatherman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/spf13/cast&#34;&gt;Cast&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Learn more and contribute on &lt;a href=&#34;https://github.com/gohugoio&#34;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
      
    </item>
    
  </channel>
</rss>
